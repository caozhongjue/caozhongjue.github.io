<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java设计模式]]></title>
    <url>%2F2019%2F05%2F26%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式的分类设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、状态模式、访问模式、中介模式、解释器模式。其他类的有：并发型模式和线程池模式。 设计模式的六大原则总原则：开闭原则开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。设计模式的六大原则总原则：开闭原则开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。1、 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类折分2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。5、迪米特法则（Demeter Principle）就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。6、合成复用原则（Composite Reuse Principle）原则是尽量首先使用合成/聚合的方式，而不是使用继承。]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程]]></title>
    <url>%2F2019%2F05%2F25%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、概念线程：比进程更小的执行单位。多线程是多任务的一种特别的形式进程：是程序的一次动态执行过程,一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束2、生命周期线程生命周期： 新建状态：使用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序start()这个线程就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。运行状态：如果就绪状态的线程获取CPU资源，就可以执行run()，此时线程便处于运行状态。运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态阻塞状态：如果一个线程执行了sleep(睡眠)、suspend(挂起)等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可分为三种：等待阻塞：运行状态中的线程执行wait()方法，使线程进入到等待阻塞状态同步阻塞：线程在获取Synchronized同步锁失败（因为同步锁被其他线程占用）其他阻塞：通过调用线程的sleep()或join()发出了I/O请求时，线程就会进入到阻塞状态。当sleep()状态超时，join()等待线程终止或超时，或者I/O处理完毕，线程重新转入就绪状态。死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。3、线程的优先级每一个java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java线程的优先级是一个整数，取值范围是1-10默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY(5).具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。创建一个线程4、Java 提供了三种创建线程的方法：通过实现 Runnable 接口；通过继承 Thread 类本身；通过 Callable 和 Future 创建线程。 //继承Thread类 package com.group.demo2019525; public class MyThread extends Thread{ private String name; public MyThread(String name) { this.name=name; } @Override public void run() { // TODO Auto-generated method stub for(int i = 10 ; i &gt;0 ; i --) { System.out.println(name+&quot;执行&quot;+i); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } //实现Runnable接口 package com.group.demo2019525; public class MyThread2 implements Runnable{ private String name; public MyThread2(String name) { this.name = name; } @Override public void run() { // TODO Auto-generated method stub for(int i =0; i &lt; 10; i++) { System.out.println(name+&quot;执行了&quot;+i); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } package com.group.demo2019525; public class MyTest { public static void main(String[] args) { MyThread mythread1 = new MyThread(&quot;A&quot;); mythread1.start(); new Thread(new MyThread2(&quot;B&quot;)).start();; } } 5、Thread和Runnable的差别实现Runable接口比继承Thread类所具有的优势：1、适合多个同样的程序代码的线程去处理同一个资源2、能够避免java中的单继承的限制3、添加程序的健壮性，代码能够被多个线程共享，代码和数据独立4、线程池仅仅能放入实现Runable或callable类线程，不能直接放入继承Thread的类 6、多线程不安全例子 //吃苹果案例 package com.group.demo2019525; public class ThreadProblem implements Runnable { private int num = 10; @Override public void run() { for (int i = 0; i &lt; 10; i++) { if(num &gt; 0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;吃了编号为&quot;+num+&quot;的苹果&quot;); num--; } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } package com.group.demo2019525; public class MyTest { public static void main(String[] args) { ThreadProblem tp = new ThreadProblem(); new Thread(tp,&quot;A&quot;).start(); new Thread(tp,&quot;B&quot;).start(); } } B吃了编号为20的苹果A吃了编号为20的苹果A吃了编号为18的苹果B吃了编号为18的苹果B吃了编号为16的苹果A吃了编号为16的苹果B吃了编号为14的苹果A吃了编号为14的苹果A吃了编号为12的苹果B吃了编号为12的苹果B吃了编号为10的苹果A吃了编号为10的苹果A吃了编号为8的苹果B吃了编号为8的苹果B吃了编号为6的苹果A吃了编号为6的苹果B吃了编号为4的苹果A吃了编号为4的苹果A吃了编号为2的苹果B吃了编号为1的苹果A吃了编号为0的苹果 线程安全问题产生的原因：1、多个线程在操作共享的数据。2、操作共享数据的线程代码有多条。3、当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。 7、解决思路:就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。在java中，用同步代码块就可以解决这个问题。同步代码块的格式 package com.group.demo2019525; public class ThreadProblem implements Runnable { private int num = 20; @Override public void run() { for (int i = 0; i &lt; 20; i++) { synchronized (ThreadProblem.class) { if(num &gt; 0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;吃了编号为&quot;+num+&quot;的苹果&quot;); --num; } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } }]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序算法]]></title>
    <url>%2F2019%2F05%2F24%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序int[] a = {8,7,4,5,6,3,1,2,9,0}冒泡排序：依次比较相邻的元素。如果第一个比第二个大，就交换他们两个。针对所有的元素以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。上面那个数组的大小为10那么就循环重复9趟，每趟相邻两个数比较为9次，下一趟相邻两个数比较为8次，逐级减1以下为输出结果 7,8,4,5,6,3,1,2,9,0,7,4,8,5,6,3,1,2,9,0,7,4,5,8,6,3,1,2,9,0,7,4,5,6,8,3,1,2,9,0,7,4,5,6,3,8,1,2,9,0,7,4,5,6,3,1,8,2,9,0,7,4,5,6,3,1,2,8,9,0,7,4,5,6,3,1,2,8,9,0,7,4,5,6,3,1,2,8,0,9, 4,7,5,6,3,1,2,8,0,9,4,5,7,6,3,1,2,8,0,9,4,5,6,7,3,1,2,8,0,9,4,5,6,3,7,1,2,8,0,9,4,5,6,3,1,7,2,8,0,9,4,5,6,3,1,2,7,8,0,9,4,5,6,3,1,2,7,8,0,9,4,5,6,3,1,2,7,0,8,9, 4,5,6,3,1,2,7,0,8,9,4,5,6,3,1,2,7,0,8,9,4,5,3,6,1,2,7,0,8,9,4,5,3,1,6,2,7,0,8,9,4,5,3,1,2,6,7,0,8,9,4,5,3,1,2,6,7,0,8,9,4,5,3,1,2,6,0,7,8,9, 4,5,3,1,2,6,0,7,8,9,4,3,5,1,2,6,0,7,8,9,4,3,1,5,2,6,0,7,8,9,4,3,1,2,5,6,0,7,8,9,4,3,1,2,5,6,0,7,8,9,4,3,1,2,5,0,6,7,8,9, 3,4,1,2,5,0,6,7,8,9,3,1,4,2,5,0,6,7,8,9,3,1,2,4,5,0,6,7,8,9,3,1,2,4,5,0,6,7,8,9,3,1,2,4,0,5,6,7,8,9, 1,3,2,4,0,5,6,7,8,9,1,2,3,4,0,5,6,7,8,9,1,2,3,4,0,5,6,7,8,9,1,2,3,0,4,5,6,7,8,9, 1,2,3,0,4,5,6,7,8,9,1,2,3,0,4,5,6,7,8,9,1,2,0,3,4,5,6,7,8,9, 1,2,0,3,4,5,6,7,8,9,1,0,2,3,4,5,6,7,8,9, 0,1,2,3,4,5,6,7,8,9, 代码如下 package com.group.demo2019524; /** * @author Administrator */ public class BubbleSort { void sort(int[] a) { for(int i =0;i &lt; a.length-1 ; i++) { for(int j =0;j &lt; a.length-1-i ; j++) { int temp ; if(a[j]&gt;a[j+1]) { temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } } public static void main(String[] args) { int[] a = {8,7,4,5,6,3,1,2,9,0} ; System.out.println(&quot;排序前：&quot;); for(int array :a) { System.out.print(array); } new BubbleSort().sort(a); System.out.println(&quot;\n排序后：&quot;); for(int array :a) { System.out.print(array); } } } 结果如下 排序前：8745631290排序后：0123456789 快速排序原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。传入getIndex (int arr[], int start, int end)的为数组arr[]、数组最初的下标起点和下标终点，而数组通过数组名称定位到数组内存所在地址，所以不需要返回值即可实现数组的改变。 在sort(int arr[], int start, int end)中首先定义三个变量start、end、key用于标识数组下标游走的起始位置、数组下标游走的最终位置、基准值。 比较start和end，start &gt;= end时表明基于基准值key左右两边已摆好（左边值比基准值key小，右边值比基准值大）。 start &lt; end则进入循环，因为选定的基准值key为原数组第一个值，所以先对原数组进行从右至左的遍历，当遇到比基准值key大或等时将标识end减少1再进行判断，直到从右至左遍历原数组中值小于基准值key时退出循环之后将此位置的值与数组之前的标识start的值arr[start]替换位置；然后再进行从左至右的遍历，当遇到比基准值key小或等时将标识start增加1再进行判断，直到从左至右遍历原数组中值大于基准值key时退出循环之后将此位置的值与数组之前的标识end的值arr[end]替换位置。 最后通过递归将当前基准值两边的杂乱数据排序，直到标识start、end回归最初的初始标记也就是查询数组的下标起点low和下标终点high。 package com.group.demo2019524; public class QuitSort { int sort(int []arr, int start, int end) { int key=arr[start]; while(start&lt;end) { //先从右到左找小于key while(start&lt;end &amp;&amp; arr[end]&gt;key) { end--; } arr[start]=arr[end]; //再从左到右找大于key while(start&lt;end &amp;&amp; arr[start]&lt;key) { start++; } arr[end]=arr[start]; } arr[start]=key; return start; } void getIndex(int[] arr, int start, int end) { if(start&lt;end) { int index=sort(arr, start, end); //递归重复排左边的 getIndex(arr, start, index-1); //递归重复排右边的 getIndex(arr, index+1, end); } } public static void main(String[] args) { int arr[] = {12,20,5,16,15,1,30,45,23,9}; int start = 0; int end = arr.length - 1; new QuitSort().getIndex(arr, start, end); for(int a : arr){ System.out.print(a + &quot; &quot;); } } } 排序前：12 20 5 16 15 1 30 45 23 9排序后：1 5 9 12 15 16 20 23 30 45 直接插入排序基本思想： 把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。 实例：0.初始状态 3，1，5，7，2，4，9，6（共8个数）有序表：3；无序表：1，5，7，2，4，9，61.第一次循环，从无序表中取出第一个数 1，把它插入到有序表中，使新的数列依旧有序有序表：1，3；无序表：5，7，2，4，9，62.第二次循环，从无序表中取出第一个数 5，把它插入到有序表中，使新的数列依旧有序有序表：1，3，5；无序表：7，2，4，9，63.第三次循环，从无序表中取出第一个数 7，把它插入到有序表中，使新的数列依旧有序有序表：1，3，5，7；无序表：2，4，9，64.第四次循环，从无序表中取出第一个数 2，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，5，7；无序表：4，9，65.第五次循环，从无序表中取出第一个数 4，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，7；无序表：9，66.第六次循环，从无序表中取出第一个数 9，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，7，9；无序表：67.第七次循环，从无序表中取出第一个数 6，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，6，7，9；无序表：（空） package com.group.demo2019524; public class InsertSort { public static void main(String[] args) { int a[] = {3,1,5,7,2,4,9,6}; System.out.println(&quot;排序前：&quot;); for(int array :a) { System.out.print(array+&quot; &quot;); } new InsertSort().sort(a); System.out.println(&quot;\n排序后：&quot;); for(int array :a) { System.out.print(array+&quot; &quot;); } } private void sort(int[] a) { // TODO Auto-generated method stub int length=a.length; int j; for(int i=1;i &lt; length ; i++) { int temp = a[i]; for(j =i-1; j&gt;=0 &amp;&amp; a[j]&gt;temp ;j--) { a[j+1]=a[j]; } a[j+1]=temp; } } } 归并排序采用递归法： ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；③. 重复步骤②，直到所有元素排序完毕懒了http://ju.outofmemory.cn/entry/372908]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%94%A8hexo%E6%90%AD%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[配置本地环境1、下载安装这两个软件 Git-2.21.0-64-bit.exe node-v10.15.3-x64.msi 如下图 2、在自己电脑某个盘里新建一个文件夹(自定义名称) 我的文件夹名称为 czjblog 3、然后在文件夹里，右键—&gt;选择Git Bash Here 就打开另一个窗口了，如下图 4、安装hexo 用命令 npm install hexo –g 如果网络好的话很快就行了 5、检查一下是否安装成功 用命令 hexo –v 出现以下图说明成功了 6、初始化自己创建的文件夹 用命令 hexo init 7、生成静态页面 用命令 hexo g 8、启动项目 用命令 hexo s 出现如下图说明启动成功 去浏览器输入 http://localhost:4000 来访问了. 配置github环境1、 首先得去github官网上面去注册一个账号 2、 然后新建一个仓库依赖，如下图 3、 然后来到这页面，如下图 https://github.com/caozhongjue/caozhongjue.github.io.git git@github.com:caozhongjue/caozhongjue.github.io.git 4、然后修改本地博客目录的配置： 修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： type: git repository: git@github.com:caozhongjue/caozhongjue.github.io.git //caozhongjue换为自己的 branch: master 5、控制台命令：npm install –save hexo-deployer-git //安装部署插件 6、由于我是用ssh 与github关联的，所以得操作这步，输入命令 ssh-keygen -t rsa -C “2857113935@qq.com” 连续回车三下生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）如下图 7、经过上面的步骤，在C:\Users\Administrator.ssh下面生成了一个id_rsa.pub文件，把里面的内容复制到 github ssh安全那里，如下面 标题随便填，键是id_rsa.pub文件里面的内容。 8、可以使用hexo d 发布项目到github上面去了 如下图 更改默认主题样式Next主题的使用说明 http://theme-next.iissnan.com/getting-started.html 1、 使用命令 git clone https://github.com/iissnan/hexo-theme-next 2、 修改项目目录下_config.yml文件内容，把theme：后面的内容换为next theme: hexo-theme-next #修改网站主题样式 title: czj’blog # author: czj #修改作者 language: zh-Hans #修改网站的显示语言，这里是中文 3、 修改项目目录下hexo-theme-next 主题下的_config.yml文件内容， menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive上面这几个就是下面的 1、添加分类模块 命令如下 hexo new page categories 你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为 title: 分类 3、打开 主题配置文件 找到menu，将categorcies取消注释 4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子： title: 分类测试文章标题 categories: 分类名 添加标签模块 命令hexo new page tags 同上 添加关于模块 命令hexo new page about 同上 highlight_theme: night bright #代码的样式 avatar: https://s2.ax1x.com/2019/05/23/VPZiAe.png #设置头像 4、 添加搜索功能 4.1、安装 hexo-generator-searchdb 插件 npm install hexo-generator-searchdb –save 4.2、打开 站点配置文件 找到Extensions在下面添加 search: path: search.xml field: post format: html limit: 100004.3、打开 主题配置文件 找到Local search，将enable设置为true 5、修改文章内链接文本样式 打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 6、首页的文章只显示一半用文本编辑器打开 themes/next 目录下的 _config.yml 文件，找到这段代码： auto_excerpt: enable: false length: 150把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。 修改后重启 hexo 就ok了。 项目的目录结构 source 文件夹存放着用markdown编辑器写的章 每次添加文章都是用markdown编辑器写好保存，放到source下面的_post文件夹下面去themes 这里存放着样式_config.yml 主站点配置文件 ，themes样式文件夹下面的文件夹里也有个样式配置文件可以使用MarkdownPad2编辑器写文章，写完后，把那个.md文章放到source下的_post文件夹下，然后右键打开窗口， 依次使用命令 hexo clean , hexo g ,hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
