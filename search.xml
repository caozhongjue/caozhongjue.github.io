<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java排序算法]]></title>
    <url>%2F2019%2F05%2F24%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序int[] a = {8,7,4,5,6,3,1,2,9,0}冒泡排序：依次比较相邻的元素。如果第一个比第二个大，就交换他们两个。针对所有的元素以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。上面那个数组的大小为10那么就循环重复9趟，每趟相邻两个数比较为9次，下一趟相邻两个数比较为8次，逐级减1以下为输出结果 7,8,4,5,6,3,1,2,9,0,7,4,8,5,6,3,1,2,9,0,7,4,5,8,6,3,1,2,9,0,7,4,5,6,8,3,1,2,9,0,7,4,5,6,3,8,1,2,9,0,7,4,5,6,3,1,8,2,9,0,7,4,5,6,3,1,2,8,9,0,7,4,5,6,3,1,2,8,9,0,7,4,5,6,3,1,2,8,0,9, 4,7,5,6,3,1,2,8,0,9,4,5,7,6,3,1,2,8,0,9,4,5,6,7,3,1,2,8,0,9,4,5,6,3,7,1,2,8,0,9,4,5,6,3,1,7,2,8,0,9,4,5,6,3,1,2,7,8,0,9,4,5,6,3,1,2,7,8,0,9,4,5,6,3,1,2,7,0,8,9, 4,5,6,3,1,2,7,0,8,9,4,5,6,3,1,2,7,0,8,9,4,5,3,6,1,2,7,0,8,9,4,5,3,1,6,2,7,0,8,9,4,5,3,1,2,6,7,0,8,9,4,5,3,1,2,6,7,0,8,9,4,5,3,1,2,6,0,7,8,9, 4,5,3,1,2,6,0,7,8,9,4,3,5,1,2,6,0,7,8,9,4,3,1,5,2,6,0,7,8,9,4,3,1,2,5,6,0,7,8,9,4,3,1,2,5,6,0,7,8,9,4,3,1,2,5,0,6,7,8,9, 3,4,1,2,5,0,6,7,8,9,3,1,4,2,5,0,6,7,8,9,3,1,2,4,5,0,6,7,8,9,3,1,2,4,5,0,6,7,8,9,3,1,2,4,0,5,6,7,8,9, 1,3,2,4,0,5,6,7,8,9,1,2,3,4,0,5,6,7,8,9,1,2,3,4,0,5,6,7,8,9,1,2,3,0,4,5,6,7,8,9, 1,2,3,0,4,5,6,7,8,9,1,2,3,0,4,5,6,7,8,9,1,2,0,3,4,5,6,7,8,9, 1,2,0,3,4,5,6,7,8,9,1,0,2,3,4,5,6,7,8,9, 0,1,2,3,4,5,6,7,8,9, 代码如下 package com.group.demo2019524; /** * @author Administrator */ public class BubbleSort { void sort(int[] a) { for(int i =0;i &lt; a.length-1 ; i++) { for(int j =0;j &lt; a.length-1-i ; j++) { int temp ; if(a[j]&gt;a[j+1]) { temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } } public static void main(String[] args) { int[] a = {8,7,4,5,6,3,1,2,9,0} ; System.out.println(&quot;排序前：&quot;); for(int array :a) { System.out.print(array); } new BubbleSort().sort(a); System.out.println(&quot;\n排序后：&quot;); for(int array :a) { System.out.print(array); } } } 结果如下 排序前：8745631290排序后：0123456789 快速排序原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。传入getIndex (int arr[], int start, int end)的为数组arr[]、数组最初的下标起点和下标终点，而数组通过数组名称定位到数组内存所在地址，所以不需要返回值即可实现数组的改变。 在sort(int arr[], int start, int end)中首先定义三个变量start、end、key用于标识数组下标游走的起始位置、数组下标游走的最终位置、基准值。 比较start和end，start &gt;= end时表明基于基准值key左右两边已摆好（左边值比基准值key小，右边值比基准值大）。 start &lt; end则进入循环，因为选定的基准值key为原数组第一个值，所以先对原数组进行从右至左的遍历，当遇到比基准值key大或等时将标识end减少1再进行判断，直到从右至左遍历原数组中值小于基准值key时退出循环之后将此位置的值与数组之前的标识start的值arr[start]替换位置；然后再进行从左至右的遍历，当遇到比基准值key小或等时将标识start增加1再进行判断，直到从左至右遍历原数组中值大于基准值key时退出循环之后将此位置的值与数组之前的标识end的值arr[end]替换位置。 最后通过递归将当前基准值两边的杂乱数据排序，直到标识start、end回归最初的初始标记也就是查询数组的下标起点low和下标终点high。 package com.group.demo2019524; public class QuitSort { int sort(int []arr, int start, int end) { int key=arr[start]; while(start&lt;end) { //先从右到左找小于key while(start&lt;end &amp;&amp; arr[end]&gt;key) { end--; } arr[start]=arr[end]; //再从左到右找大于key while(start&lt;end &amp;&amp; arr[start]&lt;key) { start++; } arr[end]=arr[start]; } arr[start]=key; return start; } void getIndex(int[] arr, int start, int end) { if(start&lt;end) { int index=sort(arr, start, end); //递归重复排左边的 getIndex(arr, start, index-1); //递归重复排右边的 getIndex(arr, index+1, end); } } public static void main(String[] args) { int arr[] = {12,20,5,16,15,1,30,45,23,9}; int start = 0; int end = arr.length - 1; new QuitSort().getIndex(arr, start, end); for(int a : arr){ System.out.print(a + &quot; &quot;); } } } 排序前：12 20 5 16 15 1 30 45 23 9排序后：1 5 9 12 15 16 20 23 30 45 直接插入排序基本思想： 把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。 实例：0.初始状态 3，1，5，7，2，4，9，6（共8个数）有序表：3；无序表：1，5，7，2，4，9，61.第一次循环，从无序表中取出第一个数 1，把它插入到有序表中，使新的数列依旧有序有序表：1，3；无序表：5，7，2，4，9，62.第二次循环，从无序表中取出第一个数 5，把它插入到有序表中，使新的数列依旧有序有序表：1，3，5；无序表：7，2，4，9，63.第三次循环，从无序表中取出第一个数 7，把它插入到有序表中，使新的数列依旧有序有序表：1，3，5，7；无序表：2，4，9，64.第四次循环，从无序表中取出第一个数 2，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，5，7；无序表：4，9，65.第五次循环，从无序表中取出第一个数 4，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，7；无序表：9，66.第六次循环，从无序表中取出第一个数 9，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，7，9；无序表：67.第七次循环，从无序表中取出第一个数 6，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，6，7，9；无序表：（空） package com.group.demo2019524; public class InsertSort { public static void main(String[] args) { int a[] = {3,1,5,7,2,4,9,6}; System.out.println(&quot;排序前：&quot;); for(int array :a) { System.out.print(array+&quot; &quot;); } new InsertSort().sort(a); System.out.println(&quot;\n排序后：&quot;); for(int array :a) { System.out.print(array+&quot; &quot;); } } private void sort(int[] a) { // TODO Auto-generated method stub int length=a.length; int j; for(int i=1;i &lt; length ; i++) { int temp = a[i]; for(j =i-1; j&gt;=0 &amp;&amp; a[j]&gt;temp ;j--) { a[j+1]=a[j]; } a[j+1]=temp; } } } 懒了http://ju.outofmemory.cn/entry/372908]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%94%A8hexo%E6%90%AD%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[配置本地环境1、下载安装这两个软件 Git-2.21.0-64-bit.exe node-v10.15.3-x64.msi 如下图 2、在自己电脑某个盘里新建一个文件夹(自定义名称) 我的文件夹名称为 czjblog 3、然后在文件夹里，右键—&gt;选择Git Bash Here 就打开另一个窗口了，如下图 4、安装hexo 用命令 npm install hexo –g 如果网络好的话很快就行了 5、检查一下是否安装成功 用命令 hexo –v 出现以下图说明成功了 6、初始化自己创建的文件夹 用命令 hexo init 7、生成静态页面 用命令 hexo g 8、启动项目 用命令 hexo s 出现如下图说明启动成功 去浏览器输入 http://localhost:4000 来访问了. 配置github环境1、 首先得去github官网上面去注册一个账号 2、 然后新建一个仓库依赖，如下图 3、 然后来到这页面，如下图 https://github.com/caozhongjue/caozhongjue.github.io.git git@github.com:caozhongjue/caozhongjue.github.io.git 4、然后修改本地博客目录的配置： 修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： type: git repository: git@github.com:caozhongjue/caozhongjue.github.io.git //caozhongjue换为自己的 branch: master 5、控制台命令：npm install –save hexo-deployer-git //安装部署插件 6、由于我是用ssh 与github关联的，所以得操作这步，输入命令 ssh-keygen -t rsa -C “2857113935@qq.com” 连续回车三下生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）如下图 7、经过上面的步骤，在C:\Users\Administrator.ssh下面生成了一个id_rsa.pub文件，把里面的内容复制到 github ssh安全那里，如下面 标题随便填，键是id_rsa.pub文件里面的内容。 8、可以使用hexo d 发布项目到github上面去了 如下图 更改默认主题样式Next主题的使用说明 http://theme-next.iissnan.com/getting-started.html 1、 使用命令 git clone https://github.com/iissnan/hexo-theme-next 2、 修改项目目录下_config.yml文件内容，把theme：后面的内容换为next theme: hexo-theme-next #修改网站主题样式 title: czj’blog # author: czj #修改作者 language: zh-Hans #修改网站的显示语言，这里是中文 3、 修改项目目录下hexo-theme-next 主题下的_config.yml文件内容， menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive上面这几个就是下面的 1、添加分类模块 命令如下 hexo new page categories 你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为 title: 分类 3、打开 主题配置文件 找到menu，将categorcies取消注释 4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子： title: 分类测试文章标题 categories: 分类名 添加标签模块 命令hexo new page tags 同上 添加关于模块 命令hexo new page about 同上 highlight_theme: night bright #代码的样式 avatar: https://s2.ax1x.com/2019/05/23/VPZiAe.png #设置头像 4、 添加搜索功能 4.1、安装 hexo-generator-searchdb 插件 npm install hexo-generator-searchdb –save 4.2、打开 站点配置文件 找到Extensions在下面添加 search: path: search.xml field: post format: html limit: 100004.3、打开 主题配置文件 找到Local search，将enable设置为true 5、修改文章内链接文本样式 打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 6、首页的文章只显示一半用文本编辑器打开 themes/next 目录下的 _config.yml 文件，找到这段代码： auto_excerpt: enable: false length: 150把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。 修改后重启 hexo 就ok了。 项目的目录结构 source 文件夹存放着用markdown编辑器写的章 每次添加文章都是用markdown编辑器写好保存，放到source下面的_post文件夹下面去themes 这里存放着样式_config.yml 主站点配置文件 ，themes样式文件夹下面的文件夹里也有个样式配置文件可以使用MarkdownPad2编辑器写文章，写完后，把那个.md文章放到source下的_post文件夹下，然后右键打开窗口， 依次使用命令 hexo clean , hexo g ,hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
