<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[oracle]]></title>
    <url>%2F2020%2F06%2F25%2Foracle%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[/*安装Oracle数据库服务端(选择性掌握)： 数据库分类主流数据库：微软sql server 2008 R2,access瑞典mysql美国oracle 10g 11g 12c小型数据库 access中型数据库mysql,sql sever大型数据库 负载级别sysbase&lt;oracle&lt;db2 安全性高 昂贵 oracle数据库官网下载 (两个文件都要下载，oracle把一个数据库文件分成两个文件压缩，不下两个你会后悔的) 客户端： a)、安装数据库客户端软件 b)、配置本地服务(即tnsnames.ora文件),用于远程连接数据库,需要的配置信息有：(必须掌握) 数据库服务器的IP(或主机名) 全局数据库名称(也即sid) 监听端口(默认是1521) 登陆数据库还需要用户名和密码*/ 数据库对象：表、视图、索引、用户、角色、表空间、存储过程、包…… 一：创建Oracle数据库对象(DDL:Data Definition Language)ddl：数据库定义语句 create alter drop truncate1、表的创建、修改与删除表是存储用户数据的基本结果。建立一个表结构的基本任务是对组成表的字段进行定义，指出该表由哪些字段组成，字段值的数据类型及对字段的约束。 **表的创建*** 创建表结构的格式： create table 表名( 列名1 数据类型 , 列名2 数据类型 , 列名3 数据类型 , 列名4 数据类型 , 列名5 数据类型 , ... 列名N 数据类型 ); create table 表名( 列名1 数据类型 [primary key], 列名2 数据类型 [unique], 列名3 数据类型 [not null | null], 列名4 数据类型 check(条件), 列名5 数据类型 [references 表名(列名)] ... 列名N 数据类型 [default 默认值] [各种约束] ); 列名命名规则：字母、数字、下划线(_)组成，不要以数字开头 数据类型：在Oracle中有很多数据类型，我们需要掌握三种：字符串、数字、日期数字：number 可以表示整数，也可以表示小数 number(5,2) 一个数为5位数的有效数，2位小数 -999.99~999.99 numbe(5) -99999~99999日期：date字符串：char、varchar2，在Oracle中，字符串用单引号引起来，用双引号引起来是别名 char是定长，如char(12)，存储内容的最大长度是12个字节，若实际存储内容只有6个字节，该列仍然占用12个字节 char(10) ‘小明’ varchar2是可变长，如varchar2(12)，存储内容的最大长度是12个字节，若实际存储内容只有6个字节，该列仍然占用6个字节 字节：字节是由二进制代码组成，二进制代码就是0和1组成，8个二进制位组成1个字节，即1B = 8b 字符：是由字节经过特定的编码方式组成，编码就相当于一个翻译官，不同的翻译官所掌握的语言也不一样，UTF-8是掌握了8国语言的翻译官，即UTF-8是国际通用字符集数据库服务器可以使用不同的翻译官(即使用不同的字符集)若数据库使用GBK或GB2312做为翻译官，那么1个中文字符占2个字节若数据库使用UTF-8做为翻译官，那么1个中文字符占3个字节建议最保守的做法是：1个中文字符占3个字节对于英文字符来说，一个字符占用1个字节。 主键(primary key)：相当于身份证号码，是唯一的，通过身份证号码只能找到一个人，即通过主键列只能找到一行数据，在创建表时，通常要有主键列,主键属于表对象，所以主键有一个名字，若没给主键指定名字，oracle会自动分配一个唯一的名字，在一个表中只能有一个主键对象 约束：就是限制 唯一约束(unique)：值不能重复，但是可以为null。属于表对象(跟列一样)，必须要有名字，若没有指定名字，则Oracle随即分配一个唯一的名字 非空约束(not null)：值不能为空，一个列默认是可以为空 主键(primary key)：相当于身份证号码，包含非空约束和唯一约束，也是属于表对象，在设计一张表示，需要有主键列 检查约束(check)：检查值是否满足某个条件，属于表对象，必须要有名字 外键(references)：也属于表对象，必须要有名字 默认值(default)：当没有给列指定值的时候，则取默认值；在创建表时，若没有给列指定默认值，那么该列的默认值是空(即null) 创建一个简单的表 create table t_student( id number, name varchar2(50), sex char(12), birthday date ); create table student_tmp( id number, name varchar2(50), sex char(12), birthday date ); 以下两个表有约束关系： create table t_class( classid number primary key, ---- 主键 classname varchar2(100) ); –sysdate：获取系统当前时间，格式是：年月日时分秒 create table t_user( t_id number primary key, ---- 主键 t_sex varchar2(20) check(t_sex = &apos;男&apos; or t_sex = &apos;女&apos;), ----- 检查 t_name varchar2(50) not null, --- 非空 t_cardid varchar2(20) unique, --- 唯一 t_birthday date default sysdate, ---- 默认值 classid number references t_class(classid) ----- 外键 ); 商品售货系统设计案例现有一个商品的数据、记录客户及其购物情况，由下三张表组成商品goods（商品号goodsid,商品名goodsname,单价untiprice,商品类别category，供应商provider）客户customer（客户号customerid，姓名name,住址address，电邮email,性别sex，身份证cardid）购买purchase（客户号customerid,商品号goodsid，购买数量nums）1、每个表格要建立主键或外键，客户的姓名不能为空值；单价必须大于0，购买数量必须在1到30之间；电邮不能重复；客户的性别必须是男或女，默认是男。 *表的修改*** ——– 查看表结构 ——–在 command window(命令窗口)下输入：desc 表名; ——–修改表：增加列 ——– alter table 表名 add(字段名1 数据类型 [not null | null],字段名2 数据类型 [not null | null]); 如果要新增多个列，则要用逗号将各列定义分开。 例：向t_student表中增加一个性别和住址字段 alter table t_student add(score number,addr varchar2(50)); alter table t_student add classid number references t_class(classid); ——–修改列：修改数据类型、约束等等——– alter table 表名modify(列名 数据类型 [default 默认值] [not null | null]); 如果要修改多个列，则要用逗号将各列定义分开。 例：修改t_student的name字段类型为varchar2(50)，且默认值为”习大大”。 alter table t_student modify name varchar2(50) default &apos;习大大&apos; not null; ——–删除列——– alter table 表名 drop column 列名; 例： alter table t_student drop column score; alter table t_student drop column addr; *表的删除**删除表结构：drop table 表名例：删除student_tmp2表 drop table student_tmp2; ——————**华丽的分割线(第一天完)**——————— emp 员工信息表，包含字段：empno 雇员编号(工号), ename 员工姓名, job 工种,mgr 员工上级的编号, hiredate 入职日期，sal 薪水， comm 奖金， deptno 部门号 dept 部门表，包含的字段： dname 部门名称， loc工作地址 二、Oracle数据库数据操作(DML:data manipulation language)/*dml：数据库操作语句，常见的增、删、改、查(最重要) 1、查询 — 注意：后面的查询案例，如无特殊说明，均以系统中存在的emp和dept两个表为例/查询的总语句select 列1,列2,列3…列N 或 from 表名/(表达式) – 数据池[where 过滤条件][group by 分组内容][having 组内条件][order by 排序方式]*/ **1.1 无条件查询(全表查询)**语法： select 列1,列2,列3...列N 或 * from 表名; –查询指定列 select empno,ename,job,mgr,hiredate,sal,comm,deptno from emp; –查询查询所有列,用*表示所有列 select * from emp; **1.2 条件查询**select 列1,列2,列3…列N 或 *from 表名[where 过滤条件] 按照指定的条件进行过滤，如“单值比较运算符”：&gt;、&lt;、=、!=或&lt;&gt;、&lt;=、&gt;=，两边的数据类型要保持一致 例：查询20号部门中全体员工的姓名、工资、和工种的有关信息。 select ename,job,sal from emp where deptno = 20; 思考以下sql，两边的数据类型是否一致？ select * from emp where sal = &apos;八百&apos;; 练习：查找出奖金超过其工资的雇员的姓名、工资、奖金和工种的信息。 —-distinct：对于指定的字段所选择的重复行，只返回一行。例：查找出20号部门中有多少种不同的工种。 select distinct job from emp where deptno = 20 /没有使用distinct关键字的结果select job from empwhere deptno = 20 / —多条件过滤之逻辑运算符:and、or例：查找出全部经理 和 第10号部门秘书的有关信息 select job,ename,sal,deptno from emp where job=&apos;MANAGER&apos; or (job=&apos;CLERK&apos; and deptno=10); 练习：查找出不是30号部门中的所有经理的所有信息。 —-多值比较运算符：(not)between 值1 and 值2, in(指定的值), not in(指定的值)例:查找出工资在2000到3000之间的职工姓名、工种和工资 select ename,job,sal from emp where sal between 2000 and 3000; 练习：查找出工资在2500到3500之外的职工姓名、工种和工资 例：查询出全部秘书、分析员或推销员的姓名、工种、工资和所在部门号 select ename,job,sal,deptno from emp where job IN(&apos;CLERK&apos;,&apos;ANALYST&apos;,&apos;SALESMAN&apos;); 练习：查询出工资分别是1500，2500，3000的分析员或推销员的姓名、工种、工资和所在部门号 —–模糊查询: like%表示匹配任意长度的字符串%test%:表示匹配中间字符串为test的任意长度的字符串 _表示仅能匹配一个字符o_a:表示匹配长度为3，以字母o开头，且以字母a结尾的字符串，中间一个字符为任意字符。 例：查询出名字以”MA”开头的全部职工的姓名、工种、工资和部门号 select ename,job,sal,deptno from emp where ename like &apos;MA%&apos;; 例：查询出名字以”SCO”开头的，长度为5位的全部职工的姓名、工种、工资和部门号 select ename,job,sal,deptno from emp where ename like &apos;SCO__&apos;; 练习：1、查找出所有工种以’MANAG’开头的职工姓名、工种和工资 2、查找出所有姓名以’ALLE’开头，且长度为5的职工姓名、工种和工资 —–is null 或 is not null例：查找出emp表中经理号(MGR)为空的职工的有关信息 select * from emp where MGR is null; 如果某字段为空，则要使用比较运算符”IS NULL”(非空使用”IS NOT NULL”)，不能用”=NULL”或”!=NULL”表示。 练习：查找出没有奖金的员工的姓名、工种、工资和部门号 **1.3 排序显示查询结果**通常情况下，查询结果是以按数据在数据库表中存储的顺序显示的。若要使查询结果按某种特定顺序显示，就要使用“ORDER BY”子句。格式：ORDER BY 字段名 ASC/DESC;字段名，指出查询出来的结果按该字段排序；选项ASC表示按升序排序，DESC表示按降序排序；默认是按升序排序。ORDER BY子句可以对查询结果按一个字段或多个字段进行排序。按多个字段排序时，先按前面的字段排序，当字段相同时，再按下一个字段排序，以此类推。 例：计算每个销售人员的年度总报酬，并按总报酬由高到低顺序显示 select ename,job,sal,comm,12*(sal+comm) sumprice from emp where job=&apos;SALESMAN&apos; order by 12*(sal+comm) DESC; —sumprice是12*(sal+comm)表达式的一个别名，该别名在标题中使用。别名不影响列的真名，它不能在查询语句的其他任何地方使用。 练习：1、查找出工资高于1000元的职工的姓名、工种、工资和部门号，并按部门号由小到大排序显示 2、查找出奖金超过本人基本工资3%的职工的姓名，工资，奖金，奖金与工资的比例，并按其比例由高到低显示 3、按工种升序，而同工种按工资降序排列显示全部职工的姓名，工种，工资。 —————————**华丽的分割线(第二天上午)**—————————- 2、向数据库中插入数据/*新增数据 insert into 表名(列1,列2...列N) values(值1,值2...值N); commit | rollback; 在Oracle字符串用单引号引起来*/ insert into t_class values (1, &apos;测试就业班&apos;); commit; insert into t_class values (2, &apos;测试周末班&apos;); rollback; –多条dml语句组成一个事物 insert into t_class values (3, &apos;安全测试班&apos;); insert into t_class values (4, &apos;JAVA开发班&apos;); commit; —— 当我们要向表中插入时间格式的数据时，需要使用to_date()函数把字符串转换为时间格式语法：to_date(char,’format’)例：向 emp 表中插入以下数据：(7250,’abc’,’CLERK’,’2222’,’1997-07-01’,250,50,20) insert into emp values(7250,&apos;abc&apos;,&apos;CLERK&apos;,&apos;2222&apos;,to_date(&apos;1997-07-01&apos;,&apos;YYYY-MM-DD&apos;),250,50,20)； 练习：在emp表中，查找1981-05-01之前入职的员工信息 3、修改数据库的数据 update 表名 set 列1 = 值1,列2 = 值2...列N = 值N [where过滤条件]; 例：将职工ALLEN提升为经理，工资增至$8000，奖金增加40% update emp set job = &apos;MANAGER&apos;,sal = 8000,comm=1.4*comm where ename = &apos;ALLEN&apos;; 练习：1、对20号部门中经理或所有销售人员提高15%的工资。 4、删除数据库的数据delete [from] 表名[where过滤条件] 例：删除emp表中工资低于500元的所有员工的信息 delete from emp where sal &lt; 500; 事务：通俗理解就是做一件事情的过程，这个过程有两种结果：成功、失败，在数据库中发出一条dml语句即开启一个事务，开启事务就一定要结束事务， 结束事务的两种方式： a1)、commit，提交事务，所有的操作都生效，操作的结果直会永久保存在数据库中 a2)、rollback，回滚事务，所有的操作都不会生效，操作的结果直接扔掉，不会永久保存到数据库中 删除表的另一种方式：truncate table 表名截断表，即删除表中所有的数据，和delete的区别： delete：会发起事务，可以有where过滤条件(即删除指定的数据),属于dml语句，删除效率比truncate低 truncate：不会发起事务，不能有where过滤条件(即只能删除表中所有的数据),属于ddl语句,删除效率比delete高，但有危险性 若表中有列是其他表的外键，则不能在该表中使用truncate(即truncate会影响外键列) drop table 表名：即删除表的数据又删除表的结构。 delete from t_student; commit; truncate from t_student; 三、单表复杂查询4.1 分组/聚合/统计函数：count() – 统计表中所有行的行数select count() from emp;count(字段) – 统计表中指定字段的非空行数select count(comm) from emp; – 练习：统计emp表中comm为空的人数 sum(字段) – 统计指定字段的和select sum(sal) 总工资 from emp;avg(字段) – 统计指定字段的平均值select avg(sal) 平均工资 from emp;max(字段) – 统计指定字段的最大值select max(sal) 最高工资 from emp;min(字段) – 统计指定字段的最小值select min(sal) 最高工资 from emp; select count(*) 总人数, count(comm) comm的非空行数, sum(sal) 总工资, avg(sal) 平均工资, max(sal) 最高工资, min(sal) 最低工资 from emp; – 例：计算emp表中公司职工的总人数及工种数 select count(*) 总人数,count(distinct job) 工种数 from emp; – 练习：计算全部销售员的年平均报酬。 select avg(sal+comm)*12 年平均报酬 from emp where job = &apos;SALESMAN&apos;; —分组函数只能从一组值中计算出一个汇总信息，所以在以上给出的查询实例中，分组函数是将查询所获得满足条件的记录行为作为一组，并返回一个统计值。如果要想“对多个组分别进行统计汇总”，例如，分别计算emp表中每个部门职工的最低工资、最高工资、平均工资和总工资，则要在查询命令中使用”GROUP BY”子句，进行分组查询。Oracle会把查询到的行分成多个组，对于每一个组返回一个汇总信息。分组查询命令的基本格式为：select 字段名from 表名[where 过滤条件][group by 字段]; 例：计算出公司支付给每个工种的总工资 select job,sum(sal) from emp group by job; 如果要将各个分组再进行划分出不同的小组，则需要在”group by”子句中指定多个列名。 例：计算每个部门中每种工种各有多少职工数。 select deptno,job,count(*) from emp group by deptno,job; 在本例中，先按部门号将职工分组，在同一部门中再按职工的工种进一部分组。但要注意，在包括”group by”子句的查询中，select子句后的列名表中，除统计函数外，均应包含在”group by”子句中(即列名表中不能出现与分组子句无关的列名)，否则出错！ 练习：统计各部门的人数。 4.2 带条件的分组查询利用”group by”子句将选择到的进行分组时，可以使用 having 子句用于限制选择的组，having子句的作用同where子句相似，都是指定查询条件。不同的是where子句对行进行选择，检查每条记录是否满足条件，而having子句是检查分组之后的各组是否满足条件。having子句是配合group by子句使用，在没有”group by”子句时不能用，并且group by和having子句在命令中要出现在where子句之后。select 字段/表达式from 表名where 单条记录的过滤条件group by 字段having 分组函数的比较表达式; 1、分组函数只能出现在select、having、order by 子句中2、如果在select语句同时含有group by、having、order by，那么他们的顺序是group by、having、order by3、group by 有一个原则,就是 select 后面的所有字段，必须出现在 group by 后面，否则，有语法错误（重要）4、有having 一定有group by 例：查询各工种组的年平均工资，要求每个工种组至少在2人以上 select job,avg(sal+nvl(comm,0))*12 avgsal,count(*) from emp group by job having count(*)&gt;2; 练习1：查询出至少有两名秘书的所有部门的部门号，并按人数降序排序。 练习2：查询出所有经理和销售人员的年平均工资，并按年平均工资降序排序。 —-总结：如果select语句后面包含了字段和统计函数，则一定要用到group by分组，并且group by后面接 select语句后面的所有字段。 ————**华丽的分割线(第二天下午完)**——— 四、多表查询1、等值连接select 表别名1.列名1,表别名1.列名2…. 或 表别名1.,表别名2.from 表名1 表别名1,表名2 表别名2,…表名n,表别名nwhere 表名1或表别名1.列名=表名2或表别名2.列名 and 表名(n-1)或表别名(n-1).列名=表名n或表别名n.列名 例：查找名字为”ALLEN”的职工所在的部门号、部门名和部门所在地 select e.ename,e.deptno,d.dname,d.loc from emp e,dept d where e.deptno=d.deptno and e.ename=&apos;ALLEN&apos;; e.deptno=d.deptno的作用：该命令对两个表进行连接查询，oracle会扫描dept表，分别检查每条记录在连接条件e.deptno=d.deptno中所用列的值从emp表取出的记录的列值是否相等。如果相等，则将这两个记录连接，产生一条新的记录作为查询到的一行，再继续从表emp中取下一条记录。重复这个步骤，一直到处理完emp表的全部符合条件的记录。如果对多个表进行连接查询，但在where子句中没有给出连接条件(称无条件连接)，则Oracle将构成一个笛卡尔积，对所有表的全部行进行组合，产生大量的行，其结果很少使用，因此在查询中要避免产生笛卡尔积。 练习：查询部门号是20,30,40的职工的员工编号，姓名，工资，部门所在位置。 显示部门号为10的部门名、员工号和工资 显示雇员名，雇员工资及所在的部门的名字，并按部门名排序 显示平均工资高于2000的部门号和它的平均工资 —-PS:多表连接查询，是重点！！！配合面试题进行讲解 *** – 分析题目的思路：1、如果有多个表，先找到这些表的相同字段；2、确定主从表。 –查询解题思路:1、确定所查询的数据来自于哪些表；2、如果查询的数据需要从多张表中获取，就需要在where字句后面，把这些表的相同字段用等于号连接起来；3、如果需要对单条数据做过滤，就把过滤条件追加到where字句后面，并用and连接起来；4、如果需要对多组数据做统计，就要使用group by字句；5、如果需要对分组后的数据做过滤，就要使用having字句；6、如果需要排序，就要使用order by字句。 2、外连接查询(左右连接)select 列名from 表名1 表别名1,表名2 表别名2where 表别名1.列名=表别名2.列名(+) 或 表别名1.列名(+)=表别名2.列名; select … from table1 t1,table2 t2 where t1.id = t2.id(+); –左连接select … from table1 t1,table2 t2 where t1.id(+) = t2.id; –右连接 在where子句的条件中必须包含外部连接操作符”(+)”。当该操作符加在表的列名上时，每当该表没有行与另一表的一行连接时，Oracle将为该表列产生空值。外键不重复的值不可能比较主键的多，所以，把操作符”(+)”加到外键上即可。主键所在的表为主表，外键所在的表为从表。 例：显示出所有部门的编号、名称和其职工的姓名与工种。select d.deptno,d.dname,e.ename,e.job from dept d, emp e where d.deptno = e.deptno(+) 左右连接的另一种写法： select * from A2 right JOIN B2 ON A2.id=B2.bid select * from A2 left JOIN B2 ON A2.id=B2.bid 以上例子，可写成以下格式： select d.deptno,d.dname,e.ename,e.job from emp e right join dept d on e.deptno = d.deptno; select d.deptno,d.dname,e.ename,e.job from dept d left join emp e on d.deptno = e.deptno; 练习：列出无雇员的部门的情况。 3、子查询格式：SELECT &lt;列名表&gt;FROM 表名WHERE 列表或表达式 比较运算符(SELECT 列名 FROM 表名 WHERE 条件); —-子查询，必须要用圆括号括起来。 单行值子查询单行值子查询，是指只返回一行(或者说是，一个记录)的子查询。例：查找出与“SMITH”在同一个部门工作的所有职工姓名及工资分析思路：select e.ename,e.salfrom emp ewhere deptno = (与“SMITH”在同一个部门) — SMITH所在的部门 select deptno from emp where ename = &apos;SMITH&apos; — 答案： select e.ename, e.sal from emp e where deptno = (select deptno from emp where ename = &apos;SMITH&apos;); –对于该子查询命令，系统执行时先执行子查询，返回一个值(即SMITH的部门号)作为主要查询(或外层查询)的条件，然后再根据该条件执行主查询选择出预期的结果，即与“SMITH”同一部门的所有职工。通常，主查询与子查询之间用”=”、”&gt;”等比较运算符进行连接。 练习：(1)、查找出工资比”SCOTT”工资高的职工的名字，工种，工资和所在的部门号，并按工资升序排序。(2)、查找出工资比”SCOTT”高，并且在”NEW YORK”工作的职工的有关情况。(3)、查找出具有最高月工资的雇员的姓名、工种和工资。(4)、查找出在”CHICAGO”工作的职工的姓名、工种和工资。 4、多行值子查询 多行子查询，是指子查询会返回多个值，此时，需要用到多值比较运算符：[NOT]IN IN运算符表示属于的关系，即是否在所选数据的集合之中。”NOT IN”表示不属于集合或不是集合的成员。 例：查找出部门10与部门30中工种相同的职工的姓名和工种。 select ename,job from emp where deptno = 10 and job in(select disctinct(job) from emp where deptno = 30); – 查找出工资在1000到3500元之间的职工所在部门的所有人员的有关信息。– 查找出工种在部门10中没有的其他部门职工的姓名、工种和工资信息。– 查找出部门20中的工种相同的职工的姓名与工种。– 查找出10号部门中的工种与销售部门中任何职工工种相同的职工的信息。 — 提示：在子查询中，查出销售部的工种。 注意：1、数据库的增加，删除，修改，都不可以使用多表连接；如果删除的数据涉及多张表，必须使用子查询。 2、删除的数据存在于多张表，必须先删从表的数据，再删主表的数据。 * 数据库扩展知识 ** 5.在from子句中使用子查询例：显示高于自己部门平均工资的员工的信息 select e.* from emp e,(select deptno, round(avg(sal+nvl(comm,0)),2) avgsal from emp group by deptno) t where e.deptno = t.deptno and e.sal &gt; t.avgsal; 练习：1、列出工资大于本部门平均工资的员工姓名和部门号及统计此部门的人数结果显示如下：EMPNAME DEPID 部门人数ZHANGSAN 1 15LISI 2 10 2、：姓名 课程 成绩张三 语文 94张三 数学 95李四 英语 88李四 语文 99李四 数学 96。。。。。。。。。。。。。。。。。。。。。找出语文，数学，英语三科成绩都大于或等于90分的学生姓名。select 姓名 from tclass where 姓名 not in(select 姓名 from tclass group by 姓名 having min(成绩)&lt;90); 六、/*伪列 rowid：属于表中的列，是由数据库自动增加的列，是真实存在的一个列，唯一标识一条数据的物理位置（查询语句首先得到数据的rowid，然后根据rowid到数据文件中唯一定位数据） 因此，根据rowid查询的效率是最高的，数据在入库时(即成功插入数据)，Oracle数据就给这条数据分配一个唯一的rowid rownum：是给结果集增加的一个序号，不属于任何的表，先有结果集，才能有rownum，始终是从1开始编号(不能跨过1而存在)*/–根据rowid查询的效率是最高的，但通常情况下不知道rowid的值，rowid是整个数据库唯一(在不同的数据库中不一定唯一)select rowid from emp where emp.rowid = ‘AAAMgzAAEAAAAAgAAA’; select rowid,emp.* from emp; –rownum不属于任何的表,以下sql是否有问题? select * from emp st where st.rownum = 1; select st.*, st.rownum from emp st; select st.*, rownum from emp st; –始终是从1开始编号(不能跨过1而存在) select * from emp where rownum &lt; 7; select * from emp st where rownum &gt; 10; select * from emp st where rownum between 1 and 10; select * from emp st where rownum between 2 and 10; select * from student st where rownum &lt;= 20 or rownum &gt;= 10; –改进–分页查询 select * from (select st.*, rownum rownum1 from student st where rownum &lt;= 20) t where rownum1 &gt;= 10; select * from (select st.*, rownum rownum1 from emp st where rownum &lt;= (select count(*) from emp)) t where rownum1 &gt;= 10; –视图就是一张临时表，不能往视图中插入、修改、删除数据，只能查询数据—切换至sys账户— create or replace view v_emp as select u.*, rownum rownum1 from USER$ u where rownum &lt;= 10; rename v_emp to v_temp; drop view v_temp; —- “索引”就是一本书的目录，提升查询数据的效率 create index i_student_name on t_student(name); drop index i_student_name; create unique index i_studnet_name on t_student(name); ——– 数据备份 ——— –*** 导出表数据 ***步骤：1、选择PL/SQL菜单栏的Tools下面的Export Tables2、切换到”SQL Inserts”窗口3、选择”Create tables”4、在Output file处，选择输出的地址，并自定义好以 .sql 结尾的文件名字，如 emp.sql5、点击Output file最右边的Export按钮即可。 –*** 导入表数据 ***步骤：1、选择PL/SQL菜单栏的Tools下面的Import Tables2、切换到”SQL Inserts”3、选择“Use Command Window”4、在Import file中选择要导入的sql文件5、点击Import file最右边的Import按钮即可。]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2020%2F06%2F25%2F%E5%88%9D%E8%AF%86python%2F</url>
    <content type="text"><![CDATA[python解释器python.exe(windows版) python.exe(mac版) 下载安装，配置环境变量 ctrl+r打开cmd黑窗口 , cd切换到（python.exe所在目录下）C:\Users\Administrator\AppData\Local\Programs\Python\Python38\ 输入命令 print(&quot;hello python&quot;) 输出结果 hello python python语言注释单行注释如下 # 或 &apos;&apos;&apos; &apos;&apos;&apos; 多行注释如下 &quot;&quot;&quot; &quot;&quot;&quot; 代码 # 单行注释 &apos;&apos;&apos; 也是单行注释 &apos;&apos;&apos; &quot;&quot;&quot; 多行注释 &quot;&quot;&quot; print(&quot;aaa22&quot;) 运算符 + - * / // 取整除 返回整数 % 取余数 返回余数 ** 幂 又称次方、乘方 代码 print(9/2) print(9//2) print(9%2) 输出结果 4.5 4 1 python缩进缩进指的是代码行开头的空格。 在其他编程语言中，代码缩进仅出于可读性的考虑，而 Python 中的缩进非常重要。 Python 使用缩进来指示代码块。 if 5 &gt; 2: print(&quot;Five is greater than two!&quot;) 如果省略缩进，Python 会出错：语法错误： if 5 &gt; 2: print(&quot;Five is greater than two!&quot;) 空格数取决于程序员，但至少需要一个。 您必须在同一代码块中使用相同数量的空格，否则 Python 会出错： if 5 &gt; 2: print(&quot;Five is greater than two!&quot;) if 5 &gt; 2: print(&quot;Five is greater than two!&quot;) 语法错误： if 5 &gt; 2: print(&quot;Five is greater than two!&quot;) print(&quot;Five is greater than two!&quot;) python变量变量是存放数据值的容器 与其他编程语言不同，python没有声明变量的命令 首次为其赋值时，才会创建变量 x = 10 y = &quot;Bill&quot; print(x) print(y) 变量不需要使用任何特定类型声明，甚至可以在设置后更改其类型。 向多个变量赋值Python 允许您在一行中为多个变量赋值： 实例 x, y, z = &quot;Orange&quot;, &quot;Banana&quot;, &quot;Cherry&quot; print(x) print(y) print(z) 输出变量Python 的 print 语句通常用于输出变量。 如需结合文本和变量，Python 使用 + 字符： 实例 x = &quot;awesome&quot; print(&quot;Python is &quot; + x) 全局变量在函数外部创建的变量（如上述所有实例所示）称为全局变量。 全局变量可以被函数内部和外部的每个人使用。 实例在函数外部创建变量，并在函数内部使用它： x = &quot;awesome&quot; def myfunc(): print(&quot;Python is &quot; + x) myfunc() global 关键字通常，在函数内部创建变量时，该变量是局部变量，只能在该函数内部使用。 要在函数内部创建全局变量，您可以使用 global 关键字。 实例如果您用了 global 关键字，则该变量属于全局范围： def myfunc(): global x x = &quot;fantastic&quot; myfunc() print(&quot;Python is &quot; + x) python数据类型 在编程中，数据类型是一个重要的概念。 变量可以存储不同类型的数据，并且不同类型可以执行不同的操作。 在这些类别中，Python 默认拥有以下内置数据类型： 文本类型： str 数值类型： int, float, complex 序列类型： list, tuple, range 映射类型： dict 集合类型： set, frozenset 布尔类型： bool 二进制类型： bytes, bytearray, memoryview 获取数据类型您可以使用 type() 函数获取任何对象的数据类型： 实例 打印变量 x 的数据类型： x = 10 print(type(x)) Python 数字Python 中有三种数字类型： int float complex 为变量赋值时，将创建数值类型的变量： 实例 x = 10 # int y = 6.3 # float z = 2j # complex 如需验证 Python 中任何对象的类型，请使用 type() 函数： 实例 print(type(x)) print(type(y)) print(type(z)) 随机数Python 没有 random() 函数来创建随机数，但 Python 有一个名为 random 的内置模块，可用于生成随机数： 实例导入 random 模块，并显示 1 到 9 之间的随机数： import random print(random.randrange(1,10))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试]]></title>
    <url>%2F2020%2F06%2F25%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[软件和软件测试软件的分类按层次分 系统软件 支持软件 应用软件 按结构划分 单机软件 分布式软件 c/s软件 b/s软件 按组织划分 开源软件 闭源（商业）软件 缺陷的由来和定义bug defect 定义 软件未实现产品说明书要求的功能 软件出现了产品说明书指明不应该出现的功能 软件实现了产品说明书未提到的功能 软件未实现产品说明书虽未明确提及但应该实现的目标 软件难以理解、不易使用、运行缓慢或者（从测试的角度看用户会认为不好） 软件测试的由来和发展由来 起源于上世纪70年代中期 *《测试数据选择的原理》 *《软件测试的艺术》 20世纪80年代早期，软件行业开始逐渐关注软件产品质量，并在公司建立的软件质量保证部门QA或SQA 发展 在国外：软件测试在公司中占有重要的地位 在国内：企业中越来越重要 软件测试的定义定义 1、正向思维定义 出发点：使自己确信产品是能够正常工作的评价一个程序和系统的特性或能力，并确定它是否达到期望的结果，软件测试就是以此为目的任何行为 2、反向思维定义 出发点：测试是为发现错误而执行一个程序或者系统的过程 测试是为了证明程序有错，而不是证明程序无错误 一个好的测试用例在于它能发现以前未发现的错误 一个成功的测试是发现了以前未发现的错误的测试 3、广义的软件测试 软件测试是对软件形成过程中的所有工作产品（包括程序以及相关文档）进行的测试，而不是仅仅是对程序的运行进行测试 验证：通过检查和提供客观证据来证实指定的需求是否满足 确认：通过检查和提供客观证据来证实特定的目的功能或应用是否己实现 4、IEEE定义的软件测试 定义：在规定条件下运行系统或构件的过程：观察和记录结果，并对系统或构件的某些方面给出评价 分析软件项目的过程：检测现有状况和所需状况之间的不同，并评估软件项目的特性 5、软件测试的目地 以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，保证各种错误和缺陷得以修复，避免软件发布后由于潜在的软件错误和缺陷造成的隐患所带来的商业风险 同时利用测试过程中得到的测试结果和测试信息，作为后续项目开发和测试过程改进的重要输入，避免在将来的项目开发和测试中重复同样的错误; 6、软件测试和调试的区别 在主体、目标、方法和思路上有所不同 测试是从己知的条件开始，使用预先定义的过程，并且有预知的结果；调试是从未知的条件开始，结束的过程可能不可预计 测试可以计划，可以预先制定测试用例和过程，工作进度可以度量；描述调试的过程或持续时间相对比较困难 测试的对象包括软件开发过程中的文档、数据以及代码，而调试的对象一般来说只是代码 7、软件测试的对象 软件=数据+文档 软件测试贯穿于整个软件生命周期中 文档 单元测试 集成测试 确认测试 系统测试 验收测试 软件的典型错误美国爱国者导弹防卸系统（1991） 迪斯尼的狮子王游戏（1994-1995） 英特尔奔腾浮点除法缺陷（1994） 美国宇航局火星登陆者号探测器（1999） 千年虫问题（1999） Windows 2000漏洞（2000） 北京奥运会门票订票网站瘫痪（2007） 温州高铁事故（2011） 对软件测试的误解和职业要求误解 如果发布的软件有质量问题，那是软件测试人员的错 软件测试技术要求不高，至少比编程容易多了 有时间就多测一些，来不及就少测一些 软件测试是测试人员的事，与开发人员无关 职业要求 善于说服 不放过蛛丝马迹 具有创造性 幽默的 善于学习 是问题的发现者 是完美追求者 有很好的洞察力 软件生命周期和软件工程软件生命周期 立项——————需求分析——————设计、编码、测试——————发布——————运行维护——————淘汰 软件工程 软件工程：包括两方面的内容：软件开发技术和软件项目管理。其中，软件开发技术包括软件开发方法学、软件工具和软件工程环境。软件项目管理包括软件质量、项目估算、进度控制、人员组织、配置管理、项目计划等 软件开发过程模型瀑布模型 优点：为项目提供了按阶段划分的检瀑布模型查点 当前一阶段完成后，只需要去关注后续阶段 缺点：各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加工作量。 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险 瀑布模型不适应用户需求的变化 快速原型模型 这种模型适合预先不能确切定义需求的软件系统的开发 优点：克服瀑布模型的缺点，减少由于软件需求不明确带来的开发风险 缺点：所选用的开发技术和工具不一定符合主流的发展；快速建立起来的系统结构加上连续的修改可能会导致产品质量低下； 增量模型 增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件 优点：可以分批次地提交软件产品； 以组件为单位进行开发降低了软件开发的风险； 开发顺序灵活； 限制：要求项目管理人员把握全局的水平较高 迭代模型 优点：降低了在一个增量上的开支风险。 降低了产品无法按照既定进度进入市场的风险。 加快了整个开发工作的进度。 迭代过程这种模式使适应需求的变化会更容易此。 螺旋模型 优点：螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。 螺旋模型更适合大型的昂贵的系统级的软件应用 软件测试过程模型V模型 揭示了开发过程与测试过程中各阶段的对应关系 缺点与不足 v模型仅仅把测试过程作为在需求分析、系统设计及编码之后的一个阶段，忽视了测试对需求分析、系统设计的验证 需求的满足一直到后期的验收测试才被验证； 没有体现出“尽早地和不断进行软件测试”的原则。 W模型 测试与开发的并行关系 优点： 测试的活动与软件开发同步进行 测试对象不仅仅是程序，包括需求和设计 尽早发现软件缺可降低软件开发的成本 局限性： 在W模型中，需求、设计、编码等活动被视为串行的，这样无法支持迭代的开发模型 H、X模型 测试过程理念 评审概述评审的定义 在正式的会议上将软件项目的成果（包括各阶段的文档、产生的代码等）提交给用户、客户或有关部门人员对软件产品进行评价和批准 需求评审 《软件需求》 《测试需求》 设计评审 《概要设计》 《详细设计》 代码评审 《代码规范》 测试评审 《测试计例》 《测试用例规范》 《缺陷报告规范》 评审的目的 评审的目标 评审的分类 评审的步骤：制定评审计划—-评审准备—–评审会议举行—-对评审结果采取行动—-评审结果被跟踪直至完成—-提交和归档]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[淘宝开店]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%B7%98%E5%AE%9D%E5%BC%80%E5%BA%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1、点淘宝千牛卖家中心，点免费开店 2、用户类型选中国大陆，接着实名认证支付宝，实名认证淘宝开店3、同意条款 4、开店完成，接着完善店铺信息，加入消保保证金，消保保证金可以交1000现金保证金给淘宝，也可选择保险保证金 5、千牛工作台 6、基础版旺铺 7、智能版旺铺 最后就是自己经营，路漫漫其修远兮]]></content>
      <categories>
        <category>开店</category>
      </categories>
      <tags>
        <tag>开店</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps操作技巧]]></title>
    <url>%2F2020%2F03%2F07%2Fps%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[快捷键ctrl+鼠标滚轮 图像左右滚动 shit+鼠标滚轮 图像上下滚动 alt+鼠标滚轮 图像放大缩小 空格键+鼠标左键 拖动画布 ctrl+r 标尺显示隐藏 ctrl+t 缩放图层 ctrl+D 取消选区 ctrl+M 曲线 ctrl+L 色阶 ctrl+J 复制图层 ctrl+alt+z 撤消 ctrl+n 新建 位图：像素图，由一个个像素点组成矢量图 F键:全屏与正常屏切换 ctrl+tab 窗口切换 rgb模式，网络，屏幕显示 ctrl+shift+s 存储为 jpg格式图片透明默认白色 png格式图片透明在图片为透明 图像大小 alt+ctrl+i 画布大小 alt+ctrl+c 存储可调品质，改变内容大小 存储为web格式，可调参数 矢量图：由一个点链接在一起组成，图片放大不会失真，区别：位图空间大，矢量图空间小 ps钢笔工具：1、点完第一个点，再点第二个点后不松手，可调线成曲线，2、按alt可调线成曲线，3、按ctrl也可调线成曲线或拖动线点位置]]></content>
      <categories>
        <category>ps</category>
      </categories>
      <tags>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享翻墙技巧]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%88%86%E4%BA%AB%E7%BF%BB%E5%A2%99%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、下载Shadowsocks.exe客户端双击启动服务器地址 172.104.99.75服务器端口 8099密码 eIW0Dnk69454e6nSwuspv9DmS201tQ0D加密方式选 aes-256-cfb最后点确定ps:这个是免费的，网络很慢，但总比不没有强，如果想网络好就自己掏钱自己搭个 2、可以在google浏览器安装SetupVPN插件，这个插件线下安装好像很麻烦，可以通过第一种方式翻出去在google浏览器应用商店直接在线安装，网络比Shadowsocks快点，不过只能在google上使用]]></content>
      <categories>
        <category>翻墙</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot实战]]></title>
    <url>%2F2019%2F08%2F29%2Fspringboot%E5%AE%9E%E6%88%982%2F</url>
    <content type="text"><![CDATA[博客后台管理系统技术栈:springboot jpa shirofreemarker layui html jquery js 第一天创建项目，我选择创建springboot模板项目，建好自带springboot依赖 &lt;!--springboot web模块--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 搭建环境，整合技术1.整合freemarker &lt;!--整合freemarker模板--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; application.yml文件添加如下 spring: freemarker: template-loader-path: classpath:/templates cache: false charset: utf-8 check-template-location: true content-type: text/html expose-request-attributes: true expose-session-attributes: true request-context-attribute: request suffix: .html 在controller文件夹下新建类 IndexController package top.caozhongjue.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class IndexController { @RequestMapping(&quot;/adminIndex&quot;) public String index(){ return &quot;index&quot;; } } 在templates文件夹下新建index.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; aaaaaa &lt;/body&gt; &lt;/html&gt; 启动springboot项目，通过启动类MyblogmanagementApplication启动 在浏览器输入 localhost:8080/adminIndex 浏览器显示 aaaaa]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git上传本地项目到github上]]></title>
    <url>%2F2019%2F08%2F25%2Fgit%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[第一次使用Git上传本地项目到github上1.下载Git软件，据说ios自带的有git软件 2.下载之后安装就很简单了，安装完成后鼠标右击或者开始-&gt;程序会出现，打开Git Bash，进入bash界面。 3.邮箱注册 在git bash界面输入如下内容即可完成邮箱的注册： git config --global user.name &quot;user.name&quot; （说明：双引号中需要你的用户名，这个可以随便输入，比如“zhangsan”） git config --global user.email &quot;2857113935@qq.com&quot; （说明： 双引号中需要输入你的有效邮箱，比如“2857113935@qq.com”） 4.查看是否存在密钥ssh keys 若出现“No such file or directory”,则表示需要创建一个ssh keys。 我的秘钥已经设置过，如下面的状态： 5.如果没设置，就创建新的ssh keys，不然git不能上传文件 ssh-keygen -t rsa -C &quot;你的邮箱名&quot; $指定目录: C:\deskbook\（说明：若在此处不输入路径，而直接按回车，则ssh keys生成后存放的路径为C:\User\文件夹下面中 输入密码: 123456 确认密码: 123456 在c:\user\administrator文件夹下。包括两个文件rd_rsa和id_rsa.pub 然后找到rd_rsa和id_rsa.pub所在目录打开idb_rsa.pub（可以把后缀名改成.txt),登录自己的GitHub账号，找到Settings,进入Settings后,点击SSH and GPG keys,然后再点击右上角添加新密钥按钮New SSH key,然后，将idb_rsa.pub里的内容拷贝到Key内，Title内容随便填，确定即可。密钥添加完成，下次在使用时就不需要再添加密钥了。 开始上传本地文件到git上。6.开始上传本地文件到git上。我们需要先创建一个本地的版本库（其实也就是一个文件夹）。你可以直接右击新建文件夹，也可以右击打开Git bash命令行窗口通过命令来创建。 现在我通过命令行在桌面新建一个testapp文件夹（你也可以在其他任何地方创建这个文件夹），并且进入这个文件夹这时桌面上就会出现一个文件夹，你可以将你的项目代码拷贝进来 7.通过命令git init把这个文件夹变成Git可管理的仓库8.这时候你就可以把你的项目粘贴到这个本地Git仓库里面（粘贴后你可以通过git status来查看你当前的状态），然后通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）。在这个过程中你其实可以一直使用git status来查看你当前的状态。如果文件内有东西会出现红色的字，不是绿色，这不是错误。这里提示你虽然把项目粘贴过来了，但还没有add到Git仓库上，然后我们通过git add .把刚才复制过来的项目全部添加到仓库上。之后再查看 git status 为绿色了9.用git commit -m “日志” 把项目提交到仓库。 10.在Github上创建一个Git仓库。你可以直接点New repository来创建，比如我创建了一个demo的仓库.进入仓库11.在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地gitdemo仓库的命令行输入： git remote add origin git@github.com:caozhongjue/demo.git 注意origin后面加的是你Github上创建好的仓库的地址,就是上图第二步点击复制的地址。关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上了，通过： git push -u origin master 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了： git push origin master 上传项目的过程可能需要等一段时间，完成之后是这样的： 有时候国内git clone下载项目很慢如下面这条命令， git clone https://github.com/caozhongjue/caozhongjue.github.io.git 真的有时候下载超级慢，我在github.com后面加.cnpmjs.org如下 git clone https://github.com.cnpmjs.org/caozhongjue/caozhongjue.github.io.git]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[微信公众平台官网微信公众平台官方网站 开发者工具 打开开发者工具，新建一个项目 编码器大概作用区域 1、获取微信的头像index.wxml文件 &lt;!--index.wxml--&gt; &lt;view class=&quot;container&quot;&gt; &lt;!-- &lt;view class=&quot;userinfo&quot;&gt; &lt;button wx:if=&quot;{{!hasUserInfo && canIUse}}&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;{{userInfo.avatarUrl}}&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;{{userInfo.nickName}}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; --&gt; &lt;image class=&quot;userinfo-avatar&quot; src=&quot;{{imagesrc}}&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;{{textattr}}&lt;/text&gt; &lt;button class=&quot;btn&quot; type=&quot;primary&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getMyInfo&quot; &gt;点击&lt;/button&gt; &lt;/view&gt; index.wxjs文件 //index.js //获取应用实例 const app = getApp() Page({ data: { motto: &apos;按钮&apos;, //userInfo: {}, imagesrc:&apos;/images/0.png&apos;, textattr:&apos;获取头像&apos;, hasUserInfo: false, canIUse: wx.canIUse(&apos;button.open-type.getUserInfo&apos;) }, //事件处理函数 bindViewTap: function() { wx.navigateTo({ url: &apos;../logs/logs&apos; }) }, getMyInfo:function(e){ console.log(e.detail.userInfo)//打印e this.setData({ imagesrc:e.detail.userInfo.avatarUrl, textattr: e.detail.userInfo.nickName }) }, onLoad: function () { if (app.globalData.userInfo) { this.setData({ userInfo: app.globalData.userInfo, hasUserInfo: true }) } else if (this.data.canIUse){ // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 app.userInfoReadyCallback = res =&gt; { this.setData({ userInfo: res.userInfo, hasUserInfo: true }) } } else { // 在没有 open-type=getUserInfo 版本的兼容处理 wx.getUserInfo({ success: res =&gt; { app.globalData.userInfo = res.userInfo this.setData({ userInfo: res.userInfo, hasUserInfo: true }) } }) } }, // getUserInfo: function(e) { // console.log(e) // app.globalData.userInfo = e.detail.userInfo // this.setData({ // userInfo: e.detail.userInfo, // hasUserInfo: true // }) // } }) index.css文件 /**index.wxss**/ .container{ width: 100%; text-align: center; /*文本居中*/ flex-direction: column;/*垂直布局*/ justify-content: space-around;/*垂直方向散布居中*/ } /*.userinfo { display: flex;flex布局*/ /* flex-direction: column;垂直布局*/ /* align-items: center;水平方向居中*/ /* justify-content: space-around;垂直方向散布居中 }*/ .userinfo-avatar { width: 128rpx;/*宽度128rpx*/ height: 128rpx;/*高度128rpx*/ margin: 20rpx;/*外边距*/ border-radius: 50%; /*边框圆形*/ } .userinfo-nickname { margin-bottom: 10rpx; margin-top: 10rpx; color: #aaa; } .btn{ margin-top: 20rpx; width: 150rpx; height: 100rpx; }]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot实战]]></title>
    <url>%2F2019%2F08%2F03%2Fspringboot%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[目录结构 1.pom.xml 文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;top.caozhongjue&lt;/groupId&gt; &lt;artifactId&gt;myblog&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;myblog&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springboot web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入thymeleaf模板引擎--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.yml文件 #整合thymeleaf spring: thymeleaf: prefix: classpath:/templates/ suffix: .html cache: false encoding: UTF-8 mode: HTML index.java文件 package top.caozhongjue.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; @Controller public class Index { @RequestMapping(&quot;/&quot;) public String index(@RequestParam(name = &quot;name&quot; )String name , Model model) { model.addAttribute(&quot;name&quot;,name); return &quot;index&quot;; } } index.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;springboot-thymeleaf demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; helloworld,您好啊，好坑啊你 asdfdasdf&lt;p th:text=&quot;&apos;hello&apos;+${name}+&apos;!&apos;&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 刚开始学各种奇葩问题问题1 编译器乱码导致Failed to load property source from location ‘classpath:/application.yml’问题2 加web依赖No active profile set, falling back to default profiles: default问题3找不到或无法加载主类 com.caozhongjue.myblog.MyblogApplication问题4 thymeleaf要想用HTML5模板要指定版本Template Mode ‘HTML5’ is deprecated. Using Template Mode ‘HTML’ instead.问题5 内存溢出D:\java\jdk\bin\java.exejava.lang.OutOfMemoryError at java.util.zip.ZipFile.open(Native Method)问题6 找不到模板org.thymeleaf.exceptions.TemplateInputException: Error resolving template [index], template might not exist or might not be accessible by any of the configured Template Resolvers\ 提交代码到github前提得下载安装git软件 git init git add git commit git remote add origin https://github.com/caozhongjue/myblog.git git push -u origin master 在idea上加入git软件idea上传代码（github上面没有这个仓库，会自动创建）idea下载代码 idea上传修改过的代码先点1更新代码，再点2提交代码，push到远程 idea快捷键 ctrl+shift+n 快速查找某个文件 alt+insert 快速生成set get方法 alt+enter 快速导入包 ctrl+D 快速复制一行 ctrl+X 复制一行 实现github授权登录功能创建一个github应用程序 操作文档说明 引入依赖 &lt;!-- okhttp 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.56&lt;/version&gt; &lt;/dependency&gt; 前端请求地址 https://github.com/login/oauth/authorize?client_id=Iv1.e73e751aed387889&amp;state=1&amp;redirect_uri=http://localhost:8080/callback&amp;scope=user AuthorizenController类 package top.caozhongjue.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import top.caozhongjue.pojo.Access_token; import top.caozhongjue.pojo.GithubUser; import top.caozhongjue.provider.GitHubProvider; import javax.servlet.http.HttpServletRequest; @Controller public class AuthorizenController { @Autowired private GitHubProvider gitHubProvider; @Value(&quot;${github.client.id}&quot;) private String clientid; @Value(&quot;${github.client.secret}&quot;) private String clientsecret; @Value(&quot;${github.redirect.uri}&quot;) private String redirecturi; @RequestMapping(&quot;/callback&quot;) public String callback(@RequestParam(name = &quot;code&quot;) String code, @RequestParam(name=&quot;state&quot;)String state, HttpServletRequest request){ Access_token access_token = new Access_token();//封装一个token实体类，存值 access_token.setCode(code); access_token.setState(state); access_token.setRedirect_uri(redirecturi); access_token.setClient_id(clientid); access_token.setClient_secret(clientsecret); String stoken = gitHubProvider.getAccess_token(access_token);//获取stoken方法，返回stoken GithubUser githubUser = gitHubProvider.getGithubUser(stoken);//获取user信息方法，返回GithubUser //System.out.println(githubUser.getLogin()+&quot;====&quot;+githubUser.getId()); if(githubUser != null){ request.getSession().setAttribute(&quot;user&quot;,githubUser); return &quot;redirect:/&quot;; //redirect重定向到哪个路径 }else{ return &quot;redirect:/&quot;; } } } GitHubProvider类 package top.caozhongjue.provider; import com.alibaba.fastjson.JSON; import okhttp3.*; import org.springframework.stereotype.Component; import top.caozhongjue.pojo.Access_token; import top.caozhongjue.pojo.GithubUser; import java.io.IOException; @Component public class GitHubProvider { //通过回调url携带code，获取token public String getAccess_token(Access_token access_token){ final MediaType json = MediaType.get(&quot;application/json; charset=utf-8&quot;); OkHttpClient client = new OkHttpClient(); RequestBody body = RequestBody.create(json, JSON.toJSONString(access_token)); Request request = new Request.Builder() .url(&quot;https://github.com/login/oauth/access_token&quot;) .post(body) .build(); try (Response response = client.newCall(request).execute()) { String string = response.body().string(); String[] split =string.split(&quot;&amp;&quot;); String stoken = split[0]; String[] splitstoken =stoken.split(&quot;=&quot;); String token = splitstoken[1]; //System.out.println(token); return token; }catch (IOException e){ e.printStackTrace(); } return null; } //携带token，获取用户信息 public GithubUser getGithubUser(String accesstoken){ OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(&quot;https://api.github.com/user?access_token=&quot;+accesstoken) .build(); try (Response response = client.newCall(request).execute()) { String string = response.body().string(); GithubUser githubUser = JSON.parseObject(string,GithubUser.class); return githubUser; }catch (IOException e){ } return null; } } GithubUser类 package top.caozhongjue.pojo; public class GithubUser { private String login; private Long id; private String bio; public String getLogin() { return login; } public void setLogin(String login) { this.login = login; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getBio() { return bio; } public void setBio(String bio) { this.bio = bio; } } Access_token类 package top.caozhongjue.pojo; public class Access_token { private String client_id; private String client_secret; private String code; private String redirect_uri; private String state; public String getClient_id() { return client_id; } public void setClient_id(String client_id) { this.client_id = client_id; } public String getClient_secret() { return client_secret; } public void setClient_secret(String client_secret) { this.client_secret = client_secret; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getRedirect_uri() { return redirect_uri; } public void setRedirect_uri(String redirect_uri) { this.redirect_uri = redirect_uri; } public String getState() { return state; } public void setState(String state) { this.state = state; } } application.yml文件自定义属性值 @Value(“${}”)取值 github: client: id: Iv1.e73e751aed387889 secret: a047b90c7d5b6de3bbd035c4af962482bae0177c redirect: uri: http://localhost:8080/callback 发布文章PublishIndex类 package top.caozhongjue.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import top.caozhongjue.dao.QuestionMapper; import top.caozhongjue.dao.UserMapper; import top.caozhongjue.pojo.Question; import top.caozhongjue.pojo.User; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; /** * 发布文章控制器 */ @Controller public class PublishController { @Autowired private QuestionMapper questionMapper; @Autowired private UserMapper userMapper; @RequestMapping(&quot;/publish&quot;) public String publish(){ return &quot;publish&quot;; } @PostMapping(&quot;/dopublish&quot;) public String doPublish( @RequestParam(&quot;title&quot;)String title, @RequestParam(&quot;description&quot;)String description, @RequestParam(&quot;tags&quot;)String tags, HttpServletRequest request, Model model){ Question question = new Question(); User user = null; Cookie[] cookies = request.getCookies(); if(cookies !=null){ for (Cookie cookie : cookies){ if(cookie.getName().equals(&quot;token&quot;)){ String token = cookie.getValue(); user = userMapper.findByToken(token); if(user != null){ request.getSession().setAttribute(&quot;user&quot;,user); } break; } } } if(user== null){ model.addAttribute(&quot;error&quot;,&quot;发表文章，请登录&quot;); return &quot;publish&quot;; } question.setTitle(title); question.setDescription(description); question.setTags(tags); question.setCreator(user.getId()); question.setGmtCreate(System.currentTimeMillis()); question.setGmtModified(question.getGmtCreate()); questionMapper.create(question); return &quot;redirect:/&quot;; } } QuestionMapper接口 package top.caozhongjue.dao; import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; import top.caozhongjue.pojo.Question; import java.util.List; @Mapper public interface QuestionMapper { @Insert(&quot;insert into question (title,description,gmt_create,gmt_modified,creator,comment_count,view_count,like_count,tags) &quot; + &quot;values(#{title},#{description},#{gmtCreate},#{gmtModified},#{creator},#{commentCount},#{viewCount},#{likeCount},#{tags})&quot;) public void create(Question question); @Select(&quot;select * from user where token = #{token}&quot;) User findByToken(@Param(&quot;token&quot;) String token); } publish页面 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;czj&apos;blog&lt;/title&gt; &lt;/head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;--&gt; &lt;!--&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt;--&gt; &lt;!--&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css/bootstrap-theme.min.css&quot;&gt;--&gt; &lt;!--最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;!--可选的 Bootstrap 主题文件（一般不用引入） --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;!--最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;body style=&quot;background-color: #efefef&quot;&gt; &lt;div style=&quot;width: 1000px;margin: auto;&quot;&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;czj 论坛&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;form class=&quot;navbar-form navbar-left&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;搜索...&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li th:if=&quot;${session.user != null}&quot;&gt; &lt;a href=&quot;/publish&quot; &gt;发布&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;dropdown&quot; th:if=&quot;${session.user != null}&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot; th:text=&quot;${session.user.getName()}&quot;&gt;&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;消息中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;退出登录&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li th:if=&quot;${session.user==null}&quot;&gt; &lt;a href=&quot;https://github.com/login/oauth/authorize?client_id=Iv1.e73e751aed387889&amp;state=1&amp;redirect_uri=http://localhost:8080/callback&amp;scope=user&quot;&gt;登录&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;div class=&quot;container-fluid&quot; style=&quot;background-color: white&quot;&gt; &lt;div class=&quot;row&quot; style=&quot;height: 100%;&quot;&gt; &lt;div class=&quot;col-lg-9 col-md-12 col-sm-12 col-xs-12&quot;&gt; &lt;h2&gt;&lt;span class=&quot;glyphicon glyphicon-plus&quot;&gt;&lt;/span&gt;发表提问&lt;/h2&gt; &lt;hr&gt; &lt;form action=&quot;/dopublish&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;问题标题(概要简述):&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;title&quot; id=&quot;title&quot; placeholder=&quot;标题&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;问题内容(详细问题内容):&lt;/label&gt; &lt;textarea name=&quot;description&quot; id=&quot;description&quot; class=&quot;form-control&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;内容&quot;&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;添加标签:&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;tags&quot; name=&quot;tags&quot; placeholder=&quot;添加标签以,隔开&quot;&gt; &lt;/div&gt; &lt;span class=&quot;alert alert-danger&quot; th:if=&quot;${error != null}&quot; th:text=&quot;${error}&quot; role=&quot;alert&quot;&gt;&lt;/span&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot; style=&quot;float: right; margin-bottom: 15px&quot;&gt;发布&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-12 col-sm-12 col-xs-12&quot;&gt; &lt;h3&gt;问题发起指南&lt;/h3&gt; 问题标题:请用精简的语言描述您发布的问题,不超过25字,问题补充:详细补充您的问题内容,并确保问题描述清析直观.ok &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 首页发布的文章显示IndexController类 package top.caozhongjue.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import top.caozhongjue.dao.QuestionMapper; import top.caozhongjue.dao.UserMapper; import top.caozhongjue.dto.PaginationDTO; import top.caozhongjue.dto.QuestionDTO; import top.caozhongjue.pojo.Question; import top.caozhongjue.pojo.User; import top.caozhongjue.services.QuestionService; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import java.util.List; /** * 首页访问路径控制器 */ @Controller public class IndexController { @Autowired private UserMapper userMapper; @Autowired private QuestionMapper questionMapper; @Autowired private QuestionService questionService; @RequestMapping(&quot;/&quot;) public String index(HttpServletRequest request, Model model,@RequestParam(value = &quot;page&quot;,defaultValue = &quot;1&quot;)Integer page, @RequestParam(value = &quot;size&quot;,defaultValue = &quot;2&quot;)Integer size) { Cookie[] cookies = request.getCookies(); if(cookies!=null){ for(Cookie cookie :cookies){ if(cookie.getName().equals(&quot;token&quot;)){ String token = cookie.getValue(); User user = userMapper.findByToken(token); if(user!=null){ request.getSession().setAttribute(&quot;user&quot;,user); } break; } } } // List&lt;QuestionDTO&gt; listQuestions = questionService.listQuestionDTO(page,size); PaginationDTO paginationDTO = questionService.listQuestionDTO(page,size); model.addAttribute(&quot;paginationDTO&quot;,paginationDTO); return &quot;index&quot;; } } QuestionServices类 package top.caozhongjue.services; import org.springframework.beans.BeanUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import top.caozhongjue.dao.QuestionMapper; import top.caozhongjue.dao.UserMapper; import top.caozhongjue.dto.PaginationDTO; import top.caozhongjue.dto.QuestionDTO; import top.caozhongjue.pojo.Question; import top.caozhongjue.pojo.User; import java.util.ArrayList; import java.util.List; @Service public class QuestionService { @Autowired private QuestionMapper questionMapper; @Autowired private UserMapper userMapper; public PaginationDTO listQuestionDTO(Integer page, Integer size) { List&lt;QuestionDTO&gt; questionDTOList = new ArrayList&lt;&gt;(); PaginationDTO paginationDTOS = new PaginationDTO(); Integer totalCount = questionMapper.count(); paginationDTOS.setPagination(totalCount,page,size); //防止超过页数据还显示 if (page&lt;1){ page=1; } if(page&gt;paginationDTOS.getTotalPages()){ page=paginationDTOS.getTotalPages(); } // mysql 分页 limit 0,5 从第0条数据开始，查出5条,第一页0-5 ，第二页5-10 ,第三页10-15 Integer offset = (page-1)*size; List&lt;Question&gt; questions = questionMapper.listQuestin(offset,size); for(Question question:questions){ User user = userMapper.findById(question.getCreator()); QuestionDTO questionDTO = new QuestionDTO(); BeanUtils.copyProperties(question,questionDTO); questionDTO.setUser(user); questionDTOList.add(questionDTO); } paginationDTOS.setQuestions(questionDTOList); //return questionDTOList; return paginationDTOS; } } QuestinDTO类 package top.caozhongjue.dto; import lombok.Data; import top.caozhongjue.pojo.User; @Data public class QuestionDTO { private Integer id; private String title; private String description; private String tags; private Long gmtCreate; private Long gmtModified; private Integer creator; private Integer viewCount; private Integer commentCount; private Integer likeCount; private User user; } PaginationDTO类 package top.caozhongjue.dto; import lombok.Data; import java.util.ArrayList; import java.util.List; @Data public class PaginationDTO { private List&lt;QuestionDTO&gt; questions;//存放数据 private boolean hasPrevious;//上一页 private boolean hasNexts;//下一页 private boolean hasFirstPage;//第一页 private boolean hasEndPage;//最后一页 private Integer currentPage;//当前页 private List&lt;Integer&gt; pages = new ArrayList&lt;&gt;();// private Integer totalPages; public void setPagination(Integer totalCount, Integer page, Integer size) { //查总共多少页 if(totalCount % size ==0){ totalPages = totalCount / size; }else{ totalPages = totalCount / size +1; } //防止超过页数据还显示 if (page&lt;1){ page=1; } if(page&gt;totalPages){ page=totalPages; } this.currentPage=page; pages.add(page); for(int i = 1; i &lt;= 3 ; i ++){ if(page-i&gt;0){ pages.add(0,page-i); } if(page+i&lt;=totalPages){ pages.add(page+i); } } //是否展示上一页 if(page == 1){ hasPrevious =false; }else{ hasPrevious = true; } //是否展示下一页 if(page == totalPages){ hasNexts = false; }else{ hasNexts = true; } //是否展示第一页 if(pages.contains(1)){ hasFirstPage = false; }else{ hasFirstPage = true; } //是否展示最后一页 if(pages.contains(totalPages)){ hasEndPage = false; }else{ hasEndPage = true; } } } QuestionMapper接口 package top.caozhongjue.dao; import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; import top.caozhongjue.pojo.Question; import java.util.List; @Mapper public interface QuestionMapper { @Select(&quot;select * from question limit #{offset},#{size}&quot;) List&lt;Question&gt; listQuestin(@Param(&quot;offset&quot;) Integer offset, @Param(&quot;size&quot;) Integer size); @Select(&quot;select count(1) from question&quot;) Integer count(); } UserMapper接口 package top.caozhongjue.dao; import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; import top.caozhongjue.pojo.User; @Mapper public interface UserMapper { @Select(&quot;select * from user where id = #{id}&quot;) User findById(@Param(&quot;id&quot;) Integer id); } 页面html &lt;div class=&quot;container-fluid&quot; style=&quot;background-color: white&quot; &gt; &lt;div class=&quot;row&quot; style=&quot;height: 100%;&quot;&gt; &lt;div class=&quot;col-lg-9 col-md-12 col-sm-12 col-xs-12&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-list&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;hr style=&quot;margin-bottom: 15px;margin-top: 15px&quot;&gt; &lt;div class=&quot;media&quot; th:each=&quot;listQuestion:${paginationDTO.questions}&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img class=&quot;media-object img-rounded&quot; th:src=&quot;${listQuestion.user.avatarUrl}&quot; style=&quot;width: 45px&quot;/&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot; th:text=&quot;${listQuestion.title}&quot;&gt;&lt;/h4&gt; &lt;span th:text=&quot;${listQuestion.description}&quot;&gt;&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;text_des&quot; &gt; &lt;span th:text=&quot;${listQuestion.commentCount}&quot;&gt;&lt;/span&gt; 个回复 • &lt;span th:text=&quot;${listQuestion.viewCount}&quot;&gt;&lt;/span&gt; 次浏览 • &lt;span th:text=&quot;${#dates.format(listQuestion.gmtCreate,&apos;yyyy-dd-MM HH:MM&apos;)}&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;!--第一页--&gt; &lt;li th:if=&quot;${paginationDTO.hasFirstPage}&quot;&gt; &lt;a href=&quot;/?page=1&quot; aria-label=&quot;Previous&quot; &gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;!--上一页--&gt; &lt;li th:if=&quot;${paginationDTO.hasPrevious}&quot;&gt; &lt;a th:href=&quot;@{/(page=${(paginationDTO.currentPage)-1})}&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;lt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li th:each=&quot;page : ${paginationDTO.pages}&quot; th:class=&quot;${paginationDTO.currentPage==page}?&apos;active&apos;:&apos;&apos; &quot; &gt; &lt;a th:href=&quot;@{/(page=${page})}&quot; th:text=&quot;${page}&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;!--下一页--&gt; &lt;li th:if=&quot;${paginationDTO.hasNexts}&quot;&gt; &lt;a th:href=&quot;@{/(page=${(paginationDTO.currentPage)+1})}&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;!--最后一页--&gt; &lt;li th:if=&quot;${paginationDTO.hasEndPage}&quot;&gt; &lt;a th:href=&quot;@{/(page=${paginationDTO.totalPages})}&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-12 col-sm-12 col-xs-12&quot; &gt; 热门话题 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php入门]]></title>
    <url>%2F2019%2F07%2F20%2Fphp%2F</url>
    <content type="text"><![CDATA[php环境搭建apache官网下载windows版本的点击 Download —-&gt; Files for Microsoft Windows点击ApacheHaus下载对应版本 配置服务器默认站点修改httpd.conf文件D:/phpserver/Apache24/ 是apache安装路径下]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js]]></title>
    <url>%2F2019%2F07%2F13%2Fjs%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[js事件js的事件机制：当行为动作满足了一定的条件后，会触发某类事务的执行。内容： 1、单双击事件单击：当鼠单击的时候会触发 onclick 双击：当鼠双击的时候会触发 ondblclick 2、鼠标事件当鼠标悬停在某个HTML元素上会触发 onmouseover 当鼠标移出某个HTML元素会触发 onmouseout 当鼠标在某个HTML元素上移动 onmousemove 3、键盘事件当键盘在某个HTML元素上弹起时触发 onkeyup 当键盘在某个HTML元素下压时触发 onkeydown 4、焦点事件获取焦点： onfocus 失去焦点： onblurs 5、页面加载事件 页面加载事件： onload js注意事项1.给合适的元素添加合适的事件2.事件冲突，如单击和双击事件3.事件的阻断 当事件所监听的函数的返回值给事件时: false:则会阻断当前事件所在的HTML标签的功能 true:则会继续执行当前事件所在的HTML标签的功能4.超链接调用js函数 &lt;a href=&quot;javascript:函数名()&quot;&gt;&lt;/a&gt; BOM浏览器对象模型windows对象的常用方法1.windows对象不用new,直接进行使用即可.2.框体方法 window.alert(&quot;&quot;); //警告框,没有返回值 window.confirm(&quot;你确定要删除吗&quot;); //确认框 ,有返回值 true/false window.prompt(&quot;请输入昵称&quot;); //提示框 3.定时和间隔方法定时器 window.setTimeout(function(){},3000); //指定时间后执行指定函数 window.setInterval(function(){},4000) //每间隔指定的时间执行指定的函数 window.clearTimeout(id); //清除指定的定时器 window.clearInterval(id); //清除每间隔指定时间的定时器 4.子窗口方法子窗口方法 window.open(&apos;page.html&apos;,&apos;newwindow&apos;,&apos;width=100,height=100,toolbar=no ,menubar=no&apos;);//弹出一个窗口 window.close();//只能打开window.open()打开的页面 window.opener.testFather(); windows对象的常用属性地址栏属性:location window.location.href=&quot;&quot;; window.location.reload=(); 历史记录属性 window.history.forward();//页面资源前进 window.history.back();//页面资源源后退 window.history.go(index); 屏幕属性 window.screen.width; window.screen.height; DOM文档对象模型1、document对象的概念浏览器对外提供的支持js的用来操作HTML文档一个对象2、使用document获取HTML元素对象直接获取，通过id class name 标签名 document.getElementById(&quot;&quot;);//通过id document.getElementByClass(&quot;&quot;);//通过class document.getElementByName(&quot;&quot;);//通过name document.getElementByTagName(&quot;&quot;);//通过标签 间接获取父子关系 document.getElementById(&quot;&quot;).childNodes; 子父关系 document.getElementById(&quot;&quot;).parentNodes; 兄弟关系 document.getElementById(&quot;&quot;).previousSibling; document.getElementById(&quot;&quot;).nextSibling; 获取属性值 &lt;input type=&quot;text&quot; name=&quot;uname&quot; id=&quot;uname&quot; value=&quot;&quot;&gt; document.getElementById(&quot;&quot;).type; document.getElementById(&quot;&quot;).name; document.getElementById(&quot;&quot;).id; 修改属性值元素对象名.属性名=属性值元素对象名.getAttribute(“属性名”);元素对象名.setAttribute(“属性名”,”属性值”); 操作元素的内容获取内容 document.getElementById(&quot;&quot;).innerHTML; document.getElementById(&quot;&quot;).innerText; 修改内容 元素对象名.innerHtml=&quot;&quot;; js给元素添加样式 document.getElementById(&quot;&quot;).style=&quot;&quot;; document.getElementById(&quot;&quot;).style.backgroundColor=&quot;&quot;; document.getElementById(&quot;&quot;).style.border=&quot;&quot; js操作HTML文档结构增加节点 document.getElementById(&quot;&quot;).innerHTML+&quot;&lt;div&gt;&lt;input &gt;&lt;/div&gt;&quot; 删除节点 1、什么是jqueryjquery全称Javascript Query 是js的一个框架,支持各种主流的浏览器。2、使用jquery]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scp传文件]]></title>
    <url>%2F2019%2F06%2F10%2Fscp%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本地window电脑上传文件到linux服务器上去 本地服务器：A 远程服务器：B1.在 A 上运行 ssh-keygen -t rsa 在C:\Users\Administrator.ssh 下生成id_rsa 和 id_rsa.pub 两个文件（在这个步骤会出现输入的提示，和密码相似）如图所示2、 在 B 上也同样运行 ssh-keygen -t rsa （步骤和上面的一样）3、 在 B 的 /root/.ssh 下创建authorized_keys文件 把A 中 id_rsa.pub.A 文件 传到 B /root/.ssh 下通过 cat 命令把id_rsa.pub.A 写到 authorized_keys 文件中（我直接打开window电脑下的id_rsa.pub.A内容放到linux服务器的authorized_keys文件里面去）4、配置完毕上传文件将本地文件拷贝到远程scp 文件名 用户名@计算机IP:远程路径（我的文件是I盘里面的文件） 从远程将文件拷回本地scp 用户名@计算机IP:文件名 本地路径 复制目录：将本地目录拷贝到远程scp -r 目录名 用户名@计算机IP:远程路径从远程将目录拷回本地scp -r 用户名@计算机IP:目录名 本地路径]]></content>
      <categories>
        <category>scp</category>
      </categories>
      <tags>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识vue]]></title>
    <url>%2F2019%2F06%2F10%2Fvue%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是vue1、vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用，Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。2、创建一个 .html 文件，然后通过如下方式引入 Vue： &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 或者： &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 声明式渲染&lt;div id=&quot;app&quot;&gt; {{msg}} &lt;h4 v-text=&quot;msg&quot;&gt;aaaa&lt;/h4&gt; &lt;span v-html=&quot;msg2&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el: &apos;#app&apos;, data: { msg: &quot;你好 vue&quot;, msg2: &quot;&lt;h2&gt;helloworld&lt;/h2&gt;&quot; } }) &lt;/script&gt; 除了文本插值，我们还可以像这样来绑定元素特性： &lt;div id=&quot;app-2&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;/div&gt; var app2 = new Vue({ el: &apos;#app-2&apos;, data: { message: &apos;页面加载于 &apos; + new Date().toLocaleString() } }) v-bind 没法实现双向绑定，v-model可以 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{msg5}}&lt;/p&gt; &lt;input type=&quot;text&quot; style=&quot;width: 100%;&quot; v-model=&quot;msg5&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el: &apos;#app&apos;, data: { msg5: &quot;大家都是好学生，爱代码，爱学习&quot; }, methods: { } }) &lt;/script&gt; v-bind 特性被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性。 事件机制&lt;div id=&quot;app&quot;&gt; &lt;button name=&quot;按钮&quot; value=&quot;按钮&quot; v-on:click=&quot;show&quot;&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el: &apos;#app&apos;, data: { }, methods: { show: function () { alert(&quot;你好啊&quot;) } } }) &lt;/script&gt; 案例&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;浪起来&quot; @click=&quot;lang&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;别浪&quot; @click=&quot;stop&quot;&gt; &lt;p&gt;{{msg4}}&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el: &apos;#app&apos;, data: { msg4: &quot;猥琐发育别浪&quot;, intervalId: null }, methods: { lang: function () { var _this = this; if(this.intervalId !=null){ return ; }else{ } this.intervalId = setInterval(function () { var start = _this.msg4.substring(0,1); var end = _this.msg4.substring(1); _this.msg4 = end+start; },400) }, stop: function () { clearInterval(this.intervalId); this.intervalId =null; } } }) &lt;/script&gt; 条件与循环&lt;div id=&quot;app-3&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt; &lt;/div&gt; var app3 = new Vue({ el: &apos;#app-3&apos;, data: { seen: true } }) 还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表： &lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; {{ todo.text }} &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; var app4 = new Vue({ el: &apos;#app-4&apos;, data: { todos: [ { text: &apos;学习 JavaScript&apos; }, { text: &apos;学习 Vue&apos; }, { text: &apos;整个牛项目&apos; } ] } }) 处理用户输入为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法： &lt;div id=&quot;app-5&quot;&gt; &lt;p&gt;{{ message }}&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt; &lt;/div&gt; var app5 = new Vue({ el: &apos;#app-5&apos;, data: { message: &apos;Hello Vue.js!&apos; }, methods: { reverseMessage: function () { this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) } } }) 组件化应用构建组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单： // 定义名为 todo-item 的新组件 Vue.component(&apos;todo-item&apos;, { template: &apos;&lt;li&gt;这是个待办项&lt;/li&gt;&apos; }) 现在你可以用它构建另一个组件模板： &lt;ol&gt; &lt;!-- 创建一个 todo-item 组件的实例 --&gt; &lt;todo-item&gt;&lt;/todo-item&gt; &lt;/ol&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux配置java环境]]></title>
    <url>%2F2019%2F03%2F16%2Flinux%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[centos安装jdk服务器阿里云 系统centos 连接工具secure crt上传文件 打开sftpsecure crt打开sftp，file–&gt;Connect Sftp Session(快捷键 alt+p)上传jdk,直接拖jdk压缩包到sftp那个窗口就行了，等上传完全用tar命令解压开文件 tar -zxvf jdk-8u201-linux-x64.tar.gz 重命名解压后的文件夹 mv jdk-8u201-linux-x64 jdk8 配置环境变量,编辑profile文件 vi /etc/profile 加入下面内容，/root/jdk8是jdk的安装路径 export JAVA_HOME=/root/jdk8 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 执行命令,使配置文件生效 source /etc/profile 查看命令,如下图 java -version javac -version centos安装mysql下载并安装MySQL官方的 Yum Repository wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。 yum -y install mysql57-community-release-el7-10.noarch.rpm 之后就开始安装MySQL服务器。 yum -y install mysql-community-server MySQL数据库设置 首先启动MySQL systemctl start mysqld.service 查看MySQL运行状态，运行状态如图： systemctl status mysqld.service 此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码： grep &quot;password&quot; /var/log/mysqld.log 如下命令进入数据库： mysql -u root -p 输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库： ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;gznc865958&apos;; (gznc865958是自己设置的)这里有个问题，新密码设置的时候如果设置的过于简单会报错： 密码的长度是由validate_password_length决定的，而validate_password_length的计算公式是： validate_password_length = validate_password_number_count + validate_password_special_char_count + (2 * validate_password_mixed_case_count) 我的是已经修改过的，初始情况下第一个的值是ON，validate_password_length是8。可以通过如下命令修改： set global validate_password_policy=0; set global validate_password_length=1; 设置 MySQL 的字符集为 UTF-8：打开 /etc 目录下的 my.cnf 文件（此文件是 MySQL 的主配置文件）： vim /etc/my.cnf 在 [mysqld] 前添加如下代码： [client] default-character-set=utf8 在 [mysqld] 后添加如下代码： character_set_server=utf8 重启mysql后 再登录，看看字符集，6个utf8就算OK show variables like &apos;%character%&apos;; centos安装tomcat上传tomcat,直接拖tomcat压缩包到sftp那个窗口就行了，等上传完全用tar命令解压开文件 tar -zxvf apache-tomcat-7.0.90.tar.gz 重命名解压后的文件夹 mv apache-tomcat-7.0.90 tomcat centos安装nginx1、需要安装gcc的环境。 yum install gcc-c++ 2、第三方的开发包。 yum install -y pcre pcre-devel yum install -y zlib zlib-devel yum install -y openssl openssl-devel 第一步：把nginx的源码包上传到linux系统第二步：解压缩，改文件夹名 tar zxf nginx-1.8.0.tar.gz mv nginx-1.8.0 nginx1.8 第三步：进入到nginx1.8文件中 使用configure命令创建一makeFile文件。 ./configure \ --prefix=/usr/local/nginx \ --pid-path=/var/run/nginx/nginx.pid \ --lock-path=/var/lock/nginx.lock \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --with-http_gzip_static_module \ --http-client-body-temp-path=/var/temp/nginx/client \ --http-proxy-temp-path=/var/temp/nginx/proxy \ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \ --http-scgi-temp-path=/var/temp/nginx/scgi 注意：启动nginx之前，上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录 mkdir /var/temp/nginx/client -p 第四步： make 第五步： make install 启动nginx进入nginx下面的sbin目录 ./nginx 查看进程 netstat -ano|grep 80 ps -ef|grep nginx 在浏览器输入主机ip加端口80,如下图关闭nginx： ./nginx -s stop 推荐使用： ./nginx -s quit 重启nginx： 1、先关闭后启动。 2、刷新配置文件： ./nginx -s reload 配置nginx反向代理 进入nginx下的conf目录下， vi nginx.conf upstream tomcatserver1{ server 119.23.17.96:8080; } server { listen 80; server_name blog.caozhongjue.top; location / { proxy_pass http://tomcatserver1; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 启动tomcat进入到tomcat的bin目录中 ./startup.sh关闭tomcat ./shutdown.sh 查看日志 cd .. cd logs tail -f catalina.out]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr]]></title>
    <url>%2F2019%2F03%2F09%2Fvultr%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、vultr的官网在vultr的官网注册自己的账号，充钱进入到自己的个人页面点那个蓝色+号,选择好自己的实例服务器地区，系统，每月扣标准，最后点 deploy now2、创建好自己的实例，打开终端控制台如下图，输root账户,密码开放端口 80 22 88913、我这Secure crt工具连4、搭建vps服务器，命令如下 wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 在输入第3条命令后 会要你选择加密方式，我直接按7回车，再回车，（为什么选7呢）因为客户端也有对应的解密方式，两者要对应出现下图才下载成功5、命令查看服务有没有启动 lsof -i:8891 如果提示命令找不到，就安装一下lsof命令 yum install lsof -y 6、先把服务干掉 kill -9 16375 （16375是进程id） 启动服务命令 ssserver -c /etc/shadowsocks.json &amp; （我用secure crt工具连服务器，每次断开后，vps服务就挂了，我添加自启动）先看看ssserver命令存放在用命令 which ssserver 我的存放在/usr/bin/ssserver下 vi /etc/rc.local 打rc.local文件在里面加这个内容 /usr/bin/ssserver -c/etc/shadowsocks.json -d start 执行下命令 chmod 777 /etc/rc.local reboot 7、最后一步，使用代理客户端shadowsocks-win-2.3（自行百度）8、打开这个工具，输入自己的服务器的ip地址，刚刚设置的端口号和密码，如果不记得了，去打开/etc/shadowsocks.json文件，里面有端口和密码9、最后访问google官网看看]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vultr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot初识]]></title>
    <url>%2F2019%2F03%2F02%2Fspringboot%2F</url>
    <content type="text"><![CDATA[什么是Spring Boot随着动态语言的流行（Ruby、Groovy、Scala、Node.js），Java的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部暑流程以及第三方技术集成难度大。 在这样的环境下，Spring Boot应运而生。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须手动进行配置）的理念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立（运行jar，内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring 配置。 Spring Boot优缺点优点（1）快速构建项目;（2）对主流开发框架的无配置集成;（3）项目可独立运行，无须外部依赖Servlet容器；（4）提供运行时的应用监控；（5）极大地提高了开发、部署效率；（6）与云计算的天然集成。缺点（1）书籍文档较少且不够深入（2）如果你不认同Spring框架，这也许是它的缺点 创建一个超级简单的的Springboot项目工具:ideamaven目录结构如下pom.xml文件内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.caozhongjue&lt;/groupId&gt; &lt;artifactId&gt;myblog&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 创建一个Controller类 package com.caozhongjue.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; /** * @author 曹忠爵 * @site * @create 2019-06-30 14:17 */ @Controller public class index { @RequestMapping(&quot;/&quot;) @ResponseBody public String index(){ return &quot;helloworld&quot;; } } 创建一个启动类 package com.caozhongjue; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.context.annotation.ComponentScan; /** * @author 曹忠爵 * @site * @create 2019-06-30 15:13 */ //@SpringBootApplication @EnableAutoConfiguration @ComponentScan(&quot;com.caozhongjue.controller&quot;) public class MBSpringBootApplication { public static void main(String[] args){ SpringApplication.run(MBSpringBootApplication.class); } } @SpringBootApplication这个注解相当于@EnableAutoConfiguration+@ComponentScan这两个注解两个注解都能启动SpringBoot项目 springboot整合jdbc目录结构 添加jdbc mysql驱动依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; application.yml文件 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: gznc865958 server: port: 8888 创建Person类 package com.caozhongjue.entity; /** * @author 曹忠爵 * @site * @create 2019-06-30 17:14 */ public class Person { private Integer id; private String name; private String sex; private Integer age; private String des; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getDes() { return des; } public void setDes(String des) { this.des = des; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } PersonController类 package com.caozhongjue.controller; import com.caozhongjue.entity.Person; import com.caozhongjue.service.PersonService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author 曹忠爵 * @site * @create 2019-06-30 19:55 */ @RestController @RequestMapping(&quot;/person&quot;) @ComponentScan(&quot;com.caozhongjue.service&quot;) public class PersonController { @Autowired private PersonService personService; @RequestMapping(&quot;/add&quot;) public String add(Person person){ return personService.add(person); } } PersonService接口 package com.caozhongjue.service; import com.caozhongjue.entity.Person; /** * @author 曹忠爵 * @site * @create 2019-06-30 20:00 */ public interface PersonService { public String add(Person person); } PersonServiceImpl类 package com.caozhongjue.service.impl; import com.caozhongjue.entity.Person; import com.caozhongjue.service.PersonService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Service; /** * @author 曹忠爵 * @site * @create 2019-06-30 20:01 */ @Service public class PersonServiceImpl implements PersonService { @Autowired private JdbcTemplate jdbcTemplate; @Override public String add(Person person) { String sql = &quot;insert into person (id,name,sex,age,des) values(null,?,?,?,?)&quot;; int effectCount=jdbcTemplate.update(sql,person.getName(),person.getSex(),person.getAge(),person.getDes()); return effectCount&gt;0?&quot;插入成功&quot;:&quot;失败了&quot;; } } @Resource与@Autowired用法区别spring中，@Resource和@Autowired都是做bean的注入时使用。使用过程中，有时候@Resource 和 @Autowired可以替换使用；有时，则不可以。 共同点@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。 不同点 @Resource是Java自己的注解，@Resource有两个属性是比较重要的，分是name和type；Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Autowired是spring的注解，是spring2.5版本引入的，Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。 springboot整合spring data jpa添加spring data jpa依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; application.yml文件 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: gznc865958 jpa: database: mysql show-sql: true hibernate: ddl-auto: update server: port: 8888 创建Student类 package com.caozhongjue.entity; import javax.persistence.*; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:12 */ @Entity public class Student { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String name; @Column private String sex; @Column private String age; @Column private String grade; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } public String getGrade() { return grade; } public void setGrade(String grade) { this.grade = grade; } } StudentController类 package com.caozhongjue.controller; import com.caozhongjue.entity.Student; import com.caozhongjue.service.StudentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:56 */ @RestController @RequestMapping(&quot;/student&quot;) public class StudentController { @Autowired private StudentService studentService; @RequestMapping(&quot;/add&quot;) public String add(Student student){ return studentService.add(student); } } StudentService接口 package com.caozhongjue.service; import com.caozhongjue.entity.Student; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:51 */ public interface StudentService { public String add(Student student); } StudentServiceImpl类 package com.caozhongjue.service.impl; import com.caozhongjue.entity.Student; import com.caozhongjue.mapper.StudentMapper; import com.caozhongjue.service.StudentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:52 */ @Service public class StudentServiceImpl implements StudentService { @Autowired private StudentMapper studentMapper; @Override public String add(Student student) { Student stu = studentMapper.save(student); return null; } } StudentMapper接口 package com.caozhongjue.mapper; import com.caozhongjue.entity.Student; import org.springframework.data.jpa.repository.JpaRepository; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:50 */ public interface StudentMapper extends JpaRepository&lt;Student,Integer&gt; { } spring boot整合 mybatis添加依赖 dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; spring boot整合freemarker 引入freemarker依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; application.properties文件 # 设定ftl文件路径 spring.freemarker.tempalte-loader-path=classpath:/templates # 关闭缓存，及时刷新，上线生产环境需要修改为true spring.freemarker.cache=false spring.freemarker.charset=UTF-8 spring.freemarker.check-template-location=true spring.freemarker.content-type=text/html spring.freemarker.expose-request-attributes=true spring.freemarker.expose-session-attributes=true spring.freemarker.request-context-attribute=request spring.freemarker.suffix=.ftl Index类 package com.example.demo.controller; import com.example.demo.util.Resource; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class index { @Autowired private Resource resource; @RequestMapping(value = &quot;index&quot;) public String index(ModelMap map){ map.addAttribute(&quot;resource&quot;,resource); return &quot;index&quot;; } } Resource类 package com.example.demo.util; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; //表示这个类是一个读取配置文件的类 @Configuration //指定配置的一些属性,其中的prefix表示前缀 @ConfigurationProperties(prefix = &quot;com.haozz.opensource&quot;) //指定所读取的配置文件的路径 @PropertySource(value = &quot;classpath:resources.properties&quot;) public class Resource { private String name; private String website; private String language; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getWebsite() { return website; } public void setWebsite(String website) { this.website = website; } public String getLanguage() { return language; } public void setLanguage(String language) { this.language = language; } } Resources.properties文件 com.haozz.opensource.name=wangshu com.haozz.opensource.website=www.haozz.top:18158/ com.haozz.opensource.language=chinese index.ftl文件 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; FreeMarker模板引擎 &lt;h1&gt;${resource.name}&lt;/h1&gt; &lt;h1&gt;${resource.website}&lt;/h1&gt; &lt;h1&gt;${resource.language}&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux centos]]></title>
    <url>%2F2019%2F02%2F23%2Flinux%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[linux各个版本根据用途不同可以做如下划分：(1)家庭用途可选择版本有：Linux Mint、Ubuntu(2)商业用途可选择版本有：Debian、RHEL、CentOS(3)挑战用途可选择版本有：Gentoo、LFS(4)理想用途可选择版本有：FreeBSD、OpenBSD、Solaris、OpenSolaris redhat、centos下载地址(1)redhat(2)centos选择dvd是比较全面的，centos minimal iso是字符界面的，没图形界面的 配置网络目录路径 /etc/sysconfig/network-scripts我的网卡是ifcfg-ens33用命令 vi ifcfg-ens33打开这个文件BOOTPROTO修改为dhcpONBOOT修改为yes重启网卡命令 service network restart 查看ip的命令 ip addr 或 ifconfigcentos7没有ifconfig命令得安装 yum install net-tools -y 配置DNS路径 /etc/ vi resolv.conf centos7 防火墙 firewalled关闭防火墙 systemctl stop firewalld开启防火墙 systemctl start firewalld重启防火墙 systemctl restart firewalld或关闭防火墙 service firewalld stop开启防火墙 service firewalld start重启防火墙 service firewalld restartcentos6 防火墙 iptables想直接执行最后一次命令直接!号加命令首写 如!ser 等于最后一次命令 service firewalld restart 查看firewall是否运行,下面两个命令都可以 systemctl status firewalld.service firewall-cmd --state 查看当前开了哪些端口其实一个服务对应一个端口，每个服务对应/usr/lib/firewalld/services下面一个xml文件。 firewall-cmd --list-services 查看所有打开的端口： firewall-cmd --zone=public --list-ports 添加开放端口 firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） 重新载入 firewall-cmd --reload 查看 firewall-cmd --zone= public --query-port=80/tcp 删除 firewall-cmd --zone= public --remove-port=80/tcp --permanent (命令如下图 注意是有两个-的) 常用命令1、linux文件目录linux根目录 /存放必要的命令 /bin存放内核以及启动所需要的文件 /boot存放硬件设备文件 /dev存放系统配置文件 /etc 普通用户宿主目录 /home存放必要的运行库 /lib超级用户的主目录 /root存放系统管理程序 /sbin存放临时的映射文件系统,通常用来挂载使用 /mnt存放临时文件 /tmp存放应用程序 /usr 命令行中# 代表是管理员身份命令行中$ 代表是普通用户身份 2、命令linux查看当前目录有哪些内容 ls linux查看当前目录有哪些内容详情 ls -l 查看当前位置 pwd 去下一级目录 cd 下一级目录 返回上一级目录 cd .. 清屏 clear 创建文件命令 touch a.txt 创建目录 mkdir 直接同时创建文夹件里再创文件夹 mkdir -p 如下图删除目录,只能删除为空的一个目录，rmdir 后面跟要删的文件夹名 rmdir 这个能删除一个文件夹里面的文件夹，上下级一起删，如下图，如果abc下有多个文件夹，则删不了全部 rmdir -p 删除命令 rm rm -r -f 删除某个文件或文件夹，不管文件夹有没有东西，参数 r 表示递归， f 表示强制删 移动命令 mv mv命令,也可以用来重命名文件，如 mv a.txt b.txt 复制命令,有覆盖内容的作用 cp abcd/a.txt abcde/b.txt cp命令 要复制目录得 用参数 r 查看文件内容命令cat直接查看全部内容，参数n显示行号 cat head查看文件内容头10行 head tail查看文件内容尾10行，tail -f 表示实时显示， tail -fn -10 表示查看实时行数 tail more查看百分几，回车继续显示 more less按屏幕大小显示，按上下键继续显示 less echo命令一个 &gt; 表示覆盖二个 &gt; 表示追加 echo &quot;aaa&quot; &gt; b.txt echo &quot;bbb&quot; &gt;&gt; b.txt 查看端口被哪个进程占用命令 netstat、ps、lsof netstat -lnp|grep 8080 或netstat -ano|grep 8080 netstat命令选项：-a all 默认不显示LISTEN相关-t tcp-u udp-n number 不显示别名，能显示数字的都用数字显示。由于不需要把数字转换成别名，所以显示的快一些-l listen 仅列出正在监听的服务状态-p program 显示建立连接的程序名-r route 路由信息-e extention 扩展信息，比如uid等-s statistic 按各个协议进行统计-c cycle 每隔一段时间周期执行netstat命令 ps -ef|grep java或ps -aux|grep java ps命令选项： 1）ps aa 显示现行终端机下的所有程序，包括其他用户的程序。2）ps -A 显示所有程序。3）ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。4）ps -e 此参数的效果和指定”A”参数相同。5）ps e 列出程序时，显示每个程序所使用的环境变量。6）ps f 用ASCII字符显示树状结构，表达程序间的相互关系。7）ps -H 显示树状结构，表示程序间的相互关系。8）ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。9）ps s 采用程序信号的格式显示程序状况。10）ps S 列出程序时，包括已中断的子程序资料。11）ps -t&lt;终端机编号&gt; 指定终端机编号，并列出属于该终端机的程序的状况12）ps u 以用户为主的格式来显示程序状况。 lsof -i:8080 lsof命令常用选项： lsof filename 显示打开指定文件的所有进程lsof -a 表示两个参数都必须满足时才显示结果lsof -c string 显示COMMAND列中包含指定字符的进程所有打开的文件lsof -u username 显示所属user进程打开的文件lsof -g gid 显示归属gid的进程情况lsof +d /DIR/ 显示目录下被进程打开的文件lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长lsof -d FD 显示指定文件描述符的进程lsof -n 不将IP转换为hostname，缺省是不加上-n参数lsof -i 用以显示符合条件的进程情况 window系统查看进程 netstat -ano 查看被占用端口对应的PID语法格式：netstat -ano | findstr “端口号” netstat -ano | findstr &quot;8080&quot; 最后一位数字就是PID，这里是9736taskkill（结束进程）强制（/F参数）杀死pid为8112的所有进程包括子进程（/T参数） taskkill /T /F /PID 9736 也可小写 taskkill /f /t /PID 9736 关机 shutdown 现在关机 shutdown now 重启 reboot 用户组查看权限 ll 修改文件的权限,r读 w写 x执行，rwx可以用421来表示 chmod u=rwx b.txt 或chmod g=rwx b.txt 只能同时对一个对象加权限 也可以这样修改权限 chmod 732 b.txt 修改文件所属用户 chown 用户名 文件名 修改文件所属组 chgrp 组名 文件名 添加用户 useradd 用户名 修改用户 usermod -L -u -l 修改密码 passwd 密码 删除用户 userdel 用户名 添加组，查找 cat /etc/group groupadd 组名 删除组 groupdel 组名 vi编辑器用vi 打开文件,后有三种模式，命令行模式，插入模式，末行模式，刚打开文件进入命令行模式，按 a i等键进入插入模式，按esc键进入末行模式，在末行模式中用:wq保存文件并退出，：q！不保存强制退出 vi b.txt rpm 安装软件1.rpm 红帽包管理工具，它适合的os(centos,redhat,fedora,suse)检查软件是否安装 rpm -q 软件名 安装软件包i=install v显示安装进度 h=显示的hash rpm -ivh 软件名称 强制安装，不一定能用 rpm -ivh --nodeps 软件名称 查看软件安装的目录 rpm -ql 软件名称 查看软件安装的版本信息 rpm -qi 软件名称 软件升级 rpm -Uvh 软件名称 软件卸载 rpm -e 软件名称 rpm -e nodeps 软件名称 强制卸载 yum 安装软件secure crt上传下载文件一、rz sz方式 1、linux服务器大多是通过ssh客户端来进行远程的登陆和管理的，使用ssh登陆linux主机以后，如何能够快速的和本地机器进行文件的交互呢，也就是上传和下载文件到服务器和本地；与ssh有关的两个命令可以提供很方便的操作：sz：将选定的文件发送（send）到本地机器rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到服务器(receive)注意：sz中的s意为send（发送），告诉客户端，我（服务器）要发送文件 send to cilent，就等同于客户端在下载。rz中的r意为received（接收），告诉客户端，我（服务器）要接收文件 received by cilent，就等同于客户端在上传2、如果linux上没有这两个命令工具，则需要先安装。可以使用yum安装。运行命令 yum install lrzsz。 3、使用条件普通Linux和Windows之间的文件共享方法，主要有建立nfs实现文件共享，和tftp之类的方法，但是都很麻烦，而如果只是小文件（几十 K，几百K），那么直接用rz/sz，就显得极其地方便了。4、如何使用从windows中拷贝/下载文件到Linux（开发板）： 运行rz后，会自动弹出WIndows下的文件选择对话框，选择对应文件后，添加，然后确定，就开始传输，将windows中的文件，拷贝到Linux中了。 将Linux中的文件拷贝到Windows中某个文件夹： 执行sz file_name 就可以将Linux当前文件夹下的文件file_name拷贝到Windows的对应目录中了，其中，Windows目录是由你当前运行的工具中设定的。 此处我用的是SecureCRT，具体的更改 rz上传/sz下载 的默认的路径的方法： 右键点击当前会话session -&gt; Session Options -&gt; Terminal -&gt; Xmodem/Zmodem -&gt;Directories : Upload : 你要设置的路径Download:你要设置的路径 二、sftp 1、为了数据和服务的安全, 很多生产环境中的Linux服务器不能使用外网环境. 在只有SSH连接的情况下, 传输文件变得很不方便.如果Linux服务器未安装用于上传和下载的lrzsz软件, 又不能现场安装, 此时可考虑使用sftp完成相关操作.SFTP是Secure File Transfer Protocol(安全文件传输协议)的缩写, 可以为传输文件提供一种安全的网络的加密方法. 不需要单独安装或配置sftp —— 支持SSH连接的服务器, 也就默认开启了SFTP. 2、SFTP与FTP的区别FTP是一种方便数据共享的文件传输协议, 包括一个FTP服务器和多个FTP客户端. FTP客户端通过FTP协议从服务器上下载资源.SFTP协议是在FTP的基础上, 对数据采取了加密/解密技术, 使数据传输更安全.SFTP的传输效率比FTP的低很多. (1) 软件环境:可以使用任意终端工具, 比如MacOS下的Terminal, 或iTerm(此处演示使用), 或SecureCRT.(2) sftp建立连接:在终端中进行操作, 若打开SecureCRT的sftp: 菜单栏的[File] –&gt; [Connect SFTP Session]即可.在默认的SSH端口(22)下连接:sftp username@remote_ip(or remote host name), 连接root用户, 则可省略”root@”. sftp root@119.23.17.96 在其他端口下的连接 sftp -o port=1000 username@remote_ip 如果出现验证, 填入正确的密码后即可实现远程连接. 连接成功后终端信息如图: sftp - 上传文件sftp与ftp有着几乎相同的语法和功能: ① ls, rm, cd, mkdir, pwd 等指令是对当前连接的远程端服务器的操作; ② lls, lrm, lcd, lmkdir, lpwd 等指令是对本地端服务器的操作 —— 在上述指令前加l(local)即可. 上传操作示例:默认连接的都是root目录, 查看本地和远端/root路径下的文件: sftp&gt; lls # 本地 anaconda-ks.cfg install.log install.log.syslog porc remote.sh test.sh sftp&gt; ls # 远端 anaconda-ks.cfg install.log install.log.syslog myid remote.sh test.sh 将本地的remote.sh文件上传至远端服务器的/home路径下: sftp&gt; put -r &quot;F:\压缩包\apache-tomcat-7.0.90.tar.gz&quot; Uploading apache-tomcat-7.0.90.tar.gz to /root/apache-tomcat-7.0.90.tar.gz sftp&gt; ls /root # 查看远端/root路径下的文件 /root/apache-tomcat-7.0.90.tar.gz sftp - 下载文件下载操作示例:将远端/root路径下的myid文件下载至本地/home路径下: sftp&gt; get -r /root/apache-tomcat-7.0.90.tar.gz Fetching /root/apache-tomcat-7.0.90.tar.gz to C:\Users\Administrator\Documents sftp&gt; lls # 查看本地路径下的文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识c++]]></title>
    <url>%2F2019%2F02%2F16%2Fc%2B%2B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C++ 简介C++是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。C++被认为是一种中级语言，它综合了高级语言和低级语言的特点。C++是由Bjarne Stroustrup于1979年在新泽西州美利山贝尔实验室开始设计开发的，扩充和完善了C语言，最初命名为带类的C，后来更改为C++。 C++完全支持面向对象的程序设计，包括面向对象开发的四大特性：1、封装2、数据隐藏3、继承4、多态 标准库标准的c++由三个重要部分组成 ：1、核心语言，提供了所有构件块，包括变量、数据类型和常量。2、C++标准库，提供了大量的函数，用于操作文件、字符串等。3、标准模板库(STL)，提供了大量的方法，用于操作数据结构等。 环境设置本地环境如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。文本编辑器：名称和版本在不同操作系统上可能会有所不同，如notepad.exe(普通记事本)、notepad++.exe、editplus等用于windows操作系统。vim和vi可用于windows和linux/unix操作系统。通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。C++ 编译器：写在源文件中的源代码是人类可读的源。它需要”编译”，转为机器语言，这样 CPU 可以按给定指令执行程序。C++ 编译器用于把源代码编译成最终的可执行程序，最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。 Windows 上的安装GUN的gcc 编译器：为了在 Windows 上安装 GCC，您需要安装 MinGW。添加您安装的 MinGW 的 bin 子目录到您的 PATH 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。编写C++的集成开发工具有vs 2008、codeblocks、dev-c++等。 C++ 基本语法1、C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。对象 - 对象具有状态和行为。类 - 类可以定义为描述对象行为/状态的模板方法 - 从基本上说，一个方法表示一种行为。即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。2、C++ 程序结构 #include &lt;iostream&gt; using namespace std; // main() 是程序开始执行的地方 int main() { cout &lt;&lt; &quot;你好,c++&quot; &lt;&lt; endl; return 0; } 2.1、C++语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。这段程序中，包含了头文件。2.2、行using namespace std;告诉编译器使用std命名空间。命名空间是C++中相对新的概念。2.3、main()是程序开始执行的地方，//是一个单行注释。2.4、int main()是主函数，程序从这里开始执行。2.5、cout &lt;&lt;”你好，c++”;会在屏幕上显示消息”Hello World”。2.6、return 0;终止main()函数，并向调用进程返回值0。 如果是用notepad记事本来编写源码，得启动命令行cmd，用g++ 文件名.cpp来译译，(前提得配置好环境变量)如下使用g++编译后，会在源文件中生成一个.exe文件。-o 这个参数 用来指定编译后的文件名。3、C++ 中的分号 &amp; 块在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。 例如，下面是三个不同的语句： x = y; y = y+1; add(x, y); 块是一组使用大括号括起来的按逻辑连接的语句。例如： { cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; } C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如： x = y; y = y+1; add(x, y); 等同于 x = y; y = y+1; add(x, y); 4、C++ 标识符C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。5、C++ 关键字下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 6、三字符组三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 三字符组 替换 ??= # ??/ \ ??&apos; ^ ??( [ ??) ] ??! | ??&lt; { ??&gt; } ??- ~ 7、C++ 注释程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。C++ 注释以 / 开始，以 / 终止。例如： /* 这是注释 */ /* C++ 注释也可以 * 跨行 */ 注释也能以 // 开始，直到行末为止。例如： #include using namespace std; main() { cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; } 当上面的代码被编译时，编译器会忽略 // prints Hello World，最后会产生以下结果： Hello World 数据类型1、数据类型使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。1.1、基本的内置类型 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 类型 位 范围 char 1个字节 -128 到 127 或者 0 到 255 unsigned char 1个字节 0 到 255 signed char 1个字节 -128 到 127 int 4个字节 -2147483648 到 2147483647 unsigned int 4个字节 0 到 4294967295 signed int 4个字节 -2147483648 到 2147483647 short int 2个字节 -32768 到 32767 unsigned short int 2个字节 0 到 65,535 signed short int 2个字节 -32768 到 32767 long int 8个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8个字节 0 to 18,446,744,073,709,551,615 float 4 个字节 +/- 3.4e +/- 38 (~7 个数字) double 8 个字节 +/- 1.7e +/- 308 (~15 个数字) long double 16 个字节 +/- 1.7e +/- 308 (~15 个数字) wchar_t 2或4个字节 1 个宽字符 typedef 声明您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称： typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： feet distance; 2、C++ 变量类型变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。 类型 描述 bool 存储值 true 或 false。 char 通常是一个八位字节（一个字节）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。 double 双精度浮点值。 void 表示类型的缺失。 wchar_t 宽字符类型。 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等2.1、C++ 中的变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; type 必须是一个有效的 C++ 数据类型，可以是 char、w_char、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明： int i, j, k; char c, ch; float f, salary; double d; 变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示： type variable_name = value; 下面列举几个实例： extern int d = 3, f = 5; // d 和 f 的声明 int d = 3, f = 5; // 定义并初始化 d 和 f byte z = 22; // 定义并初始化 z char x = &apos;x&apos;; // 变量 x 的值为 &apos;x&apos; 2.2、C++ 中的变量声明变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 #include &lt;iostream&gt; using namespace std; // 变量声明 extern int a, b; extern int c; extern float f; int main () { // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout &lt;&lt; c &lt;&lt; endl ; f = 70.0/3.0; cout &lt;&lt; f &lt;&lt; endl ; return 0; } 2.3、C++ 变量作用域作用域是程序的一个区域，一般来说有三个地方可以声明变量：在函数或一个代码块内部声明的变量，称为局部变量。在函数参数的定义中声明的变量，称为形式参数。在所有函数外部声明的变量，称为全局变量。局部变量在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量： #include &lt;iostream&gt; using namespace std; int main () { // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout &lt;&lt; c; return 0; } 全局变量在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。 全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量： #include &lt;iostream&gt; using namespace std; // 全局变量声明 int g; int main () { // 局部变量声明 int a, b; // 实际初始化 a = 10; b = 20; g = a + b; cout &lt;&lt; g; return 0; } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例： #include &lt;iostream&gt; using namespace std; // 全局变量声明 int g = 20; int main () { // 局部变量声明 int g = 10; cout &lt;&lt; g; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 10 初始化局部变量和全局变量当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char &apos;\0&apos; float 0 double 0 pointer NULL 2.4、定义常量在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。使用 const 关键字。 #define 预处理器 下面是使用 #define 预处理器定义常量的形式： #define identifier value 具体请看下面的实例： #include &lt;iostream&gt; using namespace std; #define LENGTH 10 #define WIDTH 5 #define NEWLINE &apos;\n&apos; int main() { int area; area = LENGTH * WIDTH; cout &lt;&lt; area; cout &lt;&lt; NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 const 关键字您可以使用 const 前缀声明指定类型的常量，如下所示： const type variable = value;具体请看下面的实例： #include &lt;iostream&gt; using namespace std; int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = &apos;\n&apos;; int area; area = LENGTH * WIDTH; cout &lt;&lt; area; cout &lt;&lt; NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 2.5、C++ 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。 修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned short 或 unsigned long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。 unsigned x; unsigned int y; 为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序： #include &lt;iostream&gt; using namespace std; /* * 这个程序演示了有符号整数和无符号整数之间的差别 */ int main() { short int i; // 有符号短整数 short unsigned int j; // 无符号短整数 j = 50000; i = j; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j; return 0; } 当上面的程序运行时，会输出下列结果： -15536 50000上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。 C++ 函数C++ 函数函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。 函数还有很多叫法，比如方法、子例程或程序，等等。 1、定义函数C++ 中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。函数主体：函数主体包含一组定义函数执行任务的语句。 实例以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数： // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } 函数声明函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。调用函数创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： #include &lt;iostream&gt; using namespace std; // 函数声明 int max(int num1, int num2); int main () { // 局部变量声明 int a = 100; int b = 200; int ret; // 调用函数来获取最大值 ret = max(a, b); cout &lt;&lt; &quot;Max value is : &quot; &lt;&lt; ret &lt;&lt; endl; return 0; } // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } 把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果： Max value is : 200 C++ 数组C++ 数组C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 1、声明数组在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ];这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下： double balance[10]; 现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。2、初始化数组在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示： double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果： double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例： balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： 数组表示 3、访问数组元素数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; 上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组： #include &lt;iostream&gt; using namespace std; #include &lt;iomanip&gt; using std::setw; int main () { int n[ 10 ]; // n 是一个包含 10 个整数的数组 // 初始化数组元素 for ( int i = 0; i &lt; 10; i++ ) { n[ i ] = i + 100; // 设置元素 i 为 i + 100 } cout &lt;&lt; &quot;Element&quot; &lt;&lt; setw( 13 ) &lt;&lt; &quot;Value&quot; &lt;&lt; endl; // 输出数组中每个元素的值 for ( int j = 0; j &lt; 10; j++ ) { cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl; } return 0; } 上面的程序使用了 setw() 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果： Element Value 0 100 1 101 2 102 3 103 4 104 5 105 6 106 7 107 8 108 9 109 C++ 基本的输入输出C++ 基本的输入输出C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。 C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 I/O 库头文件下列的头文件在 C++ 编程中很重要。 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 1、标准输出流（cout）预定义的对象 cout 是 ostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的，如下所示： #include &lt;iostream&gt; using namespace std; int main( ) { char str[] = &quot;Hello C++&quot;; cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl; } 当上面的代码被编译和执行时，它会产生下列结果： Value of str is : Hello C++ C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。 流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。 2、标准输入流（cin）预定义的对象 cin 是 istream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示： #include &lt;iostream&gt; using namespace std; int main( ) { char name[50]; cout &lt;&lt; &quot;请输入您的名称： &quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl; } 当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果： 请输入您的名称： cplusplus 您的名称是： cplusplus C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。 流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句： cin &gt;&gt; name &gt;&gt; age; 这相当于下面两个语句： cin &gt;&gt; name; cin &gt;&gt; age; C++ 指针C++ 指针学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： #include &lt;iostream&gt; using namespace std; int main () { int var1; char var2[10]; cout &lt;&lt; &quot;var1 变量的地址： &quot;; cout &lt;&lt; &amp;var1 &lt;&lt; endl; cout &lt;&lt; &quot;var2 变量的地址： &quot;; cout &lt;&lt; &amp;var2 &lt;&lt; endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： var1 变量的地址： 0xbfebd5c0 var2 变量的地址： 0xbfebd5b6 1、什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type var-name;在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： int *ip; /* 一个整型的指针 */ double *dp; /* 一个 double 型的指针 */ float *fp; /* 一个浮点型的指针 */ char *ch /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 C++ 中使用指针使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： #include &lt;iostream&gt; using namespace std; int main () { int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 也可以这样 int *ip = &amp;var 代替下面的; ip = &amp;var; // 在指针变量中存储 var 的地址 cout &lt;&lt; &quot;Value of var variable: &quot;; cout &lt;&lt; var &lt;&lt; endl; // 输出在指针变量中存储的地址 cout &lt;&lt; &quot;Address stored in ip variable: &quot;; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; &quot;Value of *ip variable: &quot;; cout &lt;&lt; *ip &lt;&lt; endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var variable: 20 Address stored in ip variable: 0xbfc601ac Value of *ip variable: 20]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven的认识]]></title>
    <url>%2F2019%2F02%2F09%2Fmaven%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[普通项目存在的问题1、假如正在eclipse下开发两个java项目A、B,其中A项目中的一些功能依赖于B项目中的某些类，如何维系这种依赖关系呢？处理方法就是手动把B项目打包成jar包，然后在A项目中导入B的jar包，B项目有所改动，都得重新导2、假设正在开发一个web小demo，要用到ssm这几个框架，我们必须手动去官网下载这些jar包，然后导入 maven到底是什么maven是一种软件项目管理工具，是基于项目对象模型，可以通过一小段描述信息来管理项目的构建。Maven的核心功能便是合理叙述项目间的依赖关系，通俗点讲，就是通过pom.xml文件的配置获取jar包，而不用手动去添加jar包，而这里pom.xml文件对于学了一点maven的人来说，就有些熟悉了。 通过groupId、artifactId、version三个属性就能定位一个jar包groupId里面指的是这个jar的包名(文件夹)artifactId里面指的是这个jar文件的名(项目名)version指的是jar包的版本名 maven的安装1、来到maven官方网站 http://maven.apache.org/download.cgi 下载对应的版本 如apache-maven-3.6.1-bin.zip这个2、把这个文件解压放到某个位置，目录结构如下bin文件夹下有maven的命令conf文件夹下有配置文件,如settings.xml3、配置环境变量，cmd命令窗口才能使用maven命令，和配jdk环境变量相似 仓库通过pom.xml中的配置，就能够获取到想要的jar包(还没讲解如何配置先需要了解一下仓库的概念)，但是这些jar是在哪里呢？仓库分为：本地仓库、第三方仓库(私服)、中央仓库1、本地仓库：Maven会将工程中依赖的构件(Jar包)从远程下载到本机一个目录下管理，每个电脑默认的仓库是在C:/Users/Administrator/.m2/repository下修改本地库位置：在maven安装目录下的conf/setting.xml文件中修改如： &lt;localRepository&gt;D:\tomcat\Repository&lt;/localRepository&gt; D:\tomcat\Repository：就是我们自己创建的本地仓库，将网上下载的所有jar包，都丢到该目录下，我们就可以直接通过maven的pom.xml文件直接拿。2、第三方仓库第三方仓库，又称为内部中心仓库，也称为私服私服：一般是由公司自己设立的，只为本公司内部共享使用。它既可以作为公司内部构件协作和存档，也可作为公用类库镜像缓存，减少在外部访问和下载的频率。（使用私服为了减少对中央仓库的访问私服可以使用的是局域网，中央仓库必须使用外网也就是一般公司都会创建这种第三方仓库，保证项目开发时，项目所需用的jar都从该仓库中拿，每个人的版本就都一样。3、中央仓库Maven内置了远程公用仓库：http://repo1.maven.org/maven2这个公共仓库是由Maven自己维护，里面有大量的常用类库，并包含了世界上大部分流行的开源项目构件。国内访问这个网站很慢，一般改为阿里云的，在maven安装目录下的conf/setting.xml文件中修改，在标签里添加下面这些内容保存如： &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; maven命令1、maven web项目结构pom.xml 核心配置src/main/java java源码src/main/resources java配置src/main/webapp myeclipse web项目中 WebRoot目录 |– WEB-INF |– web.xmlsrc/test 测试target 输出目录2、命令操作maven java或web项目编译：mvn compile –src/main/java目录java源码编译生成class （target目录下）测试：mvn test –src/test/java 目录编译清理：mvn clean –删除target目录，也就是将class文件等删除打包：mvn package –生成压缩文件：java项目#jar包；web项目#war包，也是放在target目录下安装：mvn install –将压缩文件(jar或者war)上传到本地仓库部署|发布：mvn deploy –将压缩文件上传私服 eclipse中使用maven]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java设计模式]]></title>
    <url>%2F2019%2F02%2F02%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式的分类设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、状态模式、访问模式、中介模式、解释器模式。其他类的有：并发型模式和线程池模式。 设计模式的六大原则设计模式的六大原则总原则：开闭原则开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。1、 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类折分2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。5、迪米特法则（Demeter Principle）就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。6、合成复用原则（Composite Reuse Principle）原则是尽量首先使用合成/聚合的方式，而不是使用继承。 单例设计模式单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。具体实现：1、 将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。2、 在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。3、 定义一个静态方法返回这个唯一对象。饿汉模式 package com.group.demo2019526; public class Singleton1 { //将自身实例化对象设置为一个属性，用static final修饰 private static final Singleton1 singleton1=new Singleton1(); //构造方法私有化 private Singleton1() {} //静态方返回该实例 public static Singleton1 getInstance() { return singleton1; } } 懒汉模式 package com.group.demo2019526; public class Singleton2 { //将自身实例化对象设置为一个属性，用static修饰 private static Singleton2 singleton2; //构造方法私有化 private Singleton2() {} //静态方法返回该实例 public static Singleton2 getIntance() { if(singleton2==null) { singleton2=new Singleton2(); } return singleton2; } } 这个是线程不安全的 package com.group.demo2019526; public class Singleton2 { //将自身实例化对象设置为一个属性，用static修饰 private static Singleton2 singleton2; //构造方法私有化 private Singleton2() {} //静态方法返回该实例 public static Singleton2 getIntance() { if(singleton2==null) { synchronized (Singleton2.class) { if(singleton2==null) { singleton2=new Singleton2(); } } } return singleton2; } } 多线程情形下，synchronized方法通常效率低，上面使用DCL双检查锁机制 动态代理设计模式用的最广泛的，用的最多的是 动态代理模式。动态代理：就是实现阶段不用关心代理是哪个，而在运行阶段指定具体哪个代理。 抽象主题类或者接口 package com.group.demo2019526; public interface IGamePlayer { public void login(String username,String password); public void killBoss(); public void upGrade(); } 需要被代理类： package com.group.demo2019526; public class GramePlayer implements IGamePlayer { private String name=&quot;&quot;; public GramePlayer(String name) { this.name = name; } @Override public void login(String username, String password) { // TODO Auto-generated method stub System.out.println(&quot;登录名为 &quot;+username+&quot; 进入游戏，&quot; + name + &quot; 登录成功！&quot;); } @Override public void killBoss() { // TODO Auto-generated method stub System.out.println(this.name + &quot; 击杀了Boss！&quot;); } @Override public void upGrade() { // TODO Auto-generated method stub System.out.println(this.name + &quot;升级了！&quot;); } } 动态代理处理器类： package com.group.demo2019526; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class GamePlayerInvocationHandler implements InvocationHandler{ private Object obj; public GamePlayerInvocationHandler(Object obj) { this.obj=obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // TODO Auto-generated method stub Object result =null; if(&quot;login&quot;.equalsIgnoreCase(method.getName())) { System.out.println(&quot;代理登录游戏&quot;); result=method.invoke(this.obj, args); return result; } result = method.invoke(this.obj, args); return result; } } 动态代理场景类： package com.group.demo2019526; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Test { public static void main(String[] args) { IGamePlayer gp = new GramePlayer(&quot;张三&quot;); InvocationHandler gpHander=new GamePlayerInvocationHandler(gp); ClassLoader classLoader = gp.getClass().getClassLoader(); Class&lt;?&gt;[] cls = new Class[] {IGamePlayer.class}; IGamePlayer proxyGp =(IGamePlayer) Proxy.newProxyInstance(classLoader, cls, gpHander); proxyGp.login(&quot;zhangsan&quot;, &quot;123456&quot;); proxyGp.killBoss(); proxyGp.upGrade(); } }]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序算法]]></title>
    <url>%2F2019%2F01%2F26%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序int[] a = {8,7,4,5,6,3,1,2,9,0}冒泡排序：依次比较相邻的元素。如果第一个比第二个大，就交换他们两个。针对所有的元素以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。上面那个数组的大小为10那么就循环重复9趟，每趟相邻两个数比较为9次，下一趟相邻两个数比较为8次，逐级减1以下为输出结果 7,8,4,5,6,3,1,2,9,0,7,4,8,5,6,3,1,2,9,0,7,4,5,8,6,3,1,2,9,0,7,4,5,6,8,3,1,2,9,0,7,4,5,6,3,8,1,2,9,0,7,4,5,6,3,1,8,2,9,0,7,4,5,6,3,1,2,8,9,0,7,4,5,6,3,1,2,8,9,0,7,4,5,6,3,1,2,8,0,9, 4,7,5,6,3,1,2,8,0,9,4,5,7,6,3,1,2,8,0,9,4,5,6,7,3,1,2,8,0,9,4,5,6,3,7,1,2,8,0,9,4,5,6,3,1,7,2,8,0,9,4,5,6,3,1,2,7,8,0,9,4,5,6,3,1,2,7,8,0,9,4,5,6,3,1,2,7,0,8,9, 4,5,6,3,1,2,7,0,8,9,4,5,6,3,1,2,7,0,8,9,4,5,3,6,1,2,7,0,8,9,4,5,3,1,6,2,7,0,8,9,4,5,3,1,2,6,7,0,8,9,4,5,3,1,2,6,7,0,8,9,4,5,3,1,2,6,0,7,8,9, 4,5,3,1,2,6,0,7,8,9,4,3,5,1,2,6,0,7,8,9,4,3,1,5,2,6,0,7,8,9,4,3,1,2,5,6,0,7,8,9,4,3,1,2,5,6,0,7,8,9,4,3,1,2,5,0,6,7,8,9, 3,4,1,2,5,0,6,7,8,9,3,1,4,2,5,0,6,7,8,9,3,1,2,4,5,0,6,7,8,9,3,1,2,4,5,0,6,7,8,9,3,1,2,4,0,5,6,7,8,9, 1,3,2,4,0,5,6,7,8,9,1,2,3,4,0,5,6,7,8,9,1,2,3,4,0,5,6,7,8,9,1,2,3,0,4,5,6,7,8,9, 1,2,3,0,4,5,6,7,8,9,1,2,3,0,4,5,6,7,8,9,1,2,0,3,4,5,6,7,8,9, 1,2,0,3,4,5,6,7,8,9,1,0,2,3,4,5,6,7,8,9, 0,1,2,3,4,5,6,7,8,9, 代码如下 package com.group.demo2019524; /** * @author Administrator */ public class BubbleSort { void sort(int[] a) { for(int i =0;i &lt; a.length-1 ; i++) { for(int j =0;j &lt; a.length-1-i ; j++) { int temp ; if(a[j]&gt;a[j+1]) { temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } } public static void main(String[] args) { int[] a = {8,7,4,5,6,3,1,2,9,0} ; System.out.println(&quot;排序前：&quot;); for(int array :a) { System.out.print(array); } new BubbleSort().sort(a); System.out.println(&quot;\n排序后：&quot;); for(int array :a) { System.out.print(array); } } } 结果如下 排序前：8745631290排序后：0123456789 快速排序原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。传入getIndex (int arr[], int start, int end)的为数组arr[]、数组最初的下标起点和下标终点，而数组通过数组名称定位到数组内存所在地址，所以不需要返回值即可实现数组的改变。 在sort(int arr[], int start, int end)中首先定义三个变量start、end、key用于标识数组下标游走的起始位置、数组下标游走的最终位置、基准值。 比较start和end，start &gt;= end时表明基于基准值key左右两边已摆好（左边值比基准值key小，右边值比基准值大）。 start &lt; end则进入循环，因为选定的基准值key为原数组第一个值，所以先对原数组进行从右至左的遍历，当遇到比基准值key大或等时将标识end减少1再进行判断，直到从右至左遍历原数组中值小于基准值key时退出循环之后将此位置的值与数组之前的标识start的值arr[start]替换位置；然后再进行从左至右的遍历，当遇到比基准值key小或等时将标识start增加1再进行判断，直到从左至右遍历原数组中值大于基准值key时退出循环之后将此位置的值与数组之前的标识end的值arr[end]替换位置。 最后通过递归将当前基准值两边的杂乱数据排序，直到标识start、end回归最初的初始标记也就是查询数组的下标起点low和下标终点high。 package com.group.demo2019524; public class QuitSort { int sort(int []arr, int start, int end) { int key=arr[start]; while(start&lt;end) { //先从右到左找小于key while(start&lt;end &amp;&amp; arr[end]&gt;key) { end--; } arr[start]=arr[end]; //再从左到右找大于key while(start&lt;end &amp;&amp; arr[start]&lt;key) { start++; } arr[end]=arr[start]; } arr[start]=key; return start; } void getIndex(int[] arr, int start, int end) { if(start&lt;end) { int index=sort(arr, start, end); //递归重复排左边的 getIndex(arr, start, index-1); //递归重复排右边的 getIndex(arr, index+1, end); } } public static void main(String[] args) { int arr[] = {12,20,5,16,15,1,30,45,23,9}; int start = 0; int end = arr.length - 1; new QuitSort().getIndex(arr, start, end); for(int a : arr){ System.out.print(a + &quot; &quot;); } } } 排序前：12 20 5 16 15 1 30 45 23 9排序后：1 5 9 12 15 16 20 23 30 45 直接插入排序基本思想： 把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。 实例：0.初始状态 3，1，5，7，2，4，9，6（共8个数）有序表：3；无序表：1，5，7，2，4，9，61.第一次循环，从无序表中取出第一个数 1，把它插入到有序表中，使新的数列依旧有序有序表：1，3；无序表：5，7，2，4，9，62.第二次循环，从无序表中取出第一个数 5，把它插入到有序表中，使新的数列依旧有序有序表：1，3，5；无序表：7，2，4，9，63.第三次循环，从无序表中取出第一个数 7，把它插入到有序表中，使新的数列依旧有序有序表：1，3，5，7；无序表：2，4，9，64.第四次循环，从无序表中取出第一个数 2，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，5，7；无序表：4，9，65.第五次循环，从无序表中取出第一个数 4，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，7；无序表：9，66.第六次循环，从无序表中取出第一个数 9，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，7，9；无序表：67.第七次循环，从无序表中取出第一个数 6，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，6，7，9；无序表：（空） package com.group.demo2019524; public class InsertSort { public static void main(String[] args) { int a[] = {3,1,5,7,2,4,9,6}; System.out.println(&quot;排序前：&quot;); for(int array :a) { System.out.print(array+&quot; &quot;); } new InsertSort().sort(a); System.out.println(&quot;\n排序后：&quot;); for(int array :a) { System.out.print(array+&quot; &quot;); } } private void sort(int[] a) { // TODO Auto-generated method stub int length=a.length; int j; for(int i=1;i &lt; length ; i++) { int temp = a[i]; for(j =i-1; j&gt;=0 &amp;&amp; a[j]&gt;temp ;j--) { a[j+1]=a[j]; } a[j+1]=temp; } } } 归并排序采用递归法： ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；③. 重复步骤②，直到所有元素排序完毕 package com.group.demo2019524; public class MergeSort { public static void merge(int[] a, int start, int mid, int end) { int[] tmp = new int[a.length]; System.out.println(&quot;merge &quot; + start + &quot;~&quot; + end); int i = start, j = mid + 1, k = start; while (i &lt; mid + 1 &amp;&amp; j &lt; end + 1) { if (a[i] &lt; a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } while (i != mid + 1) tmp[k++] = a[i++]; while (j != end + 1) tmp[k++] = a[j++]; for (i = start; i &lt;= end; i++) a[i] = tmp[i]; for (int p : a) System.out.print(p + &quot; &quot;); System.out.println(); } static void mergeSort(int[] a, int start, int end) { if (start &lt; end) { int mid = (start + end) / 2; mergeSort(a, start, mid);// 左边有序 mergeSort(a, mid + 1, end);// 右边有序 merge(a, start, mid, end); } } public static void main(String[] args) { int[] b = { 49, 38, 65, 97, 76, 13, 27, 50 }; mergeSort(b, 0, b.length - 1); } } 懒了http://ju.outofmemory.cn/entry/372908]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程]]></title>
    <url>%2F2019%2F01%2F19%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、概念线程：比进程更小的执行单位。多线程是多任务的一种特别的形式进程：是程序的一次动态执行过程,一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束2、生命周期线程生命周期： 新建状态：使用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序start()这个线程就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。运行状态：如果就绪状态的线程获取CPU资源，就可以执行run()，此时线程便处于运行状态。运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态阻塞状态：如果一个线程执行了sleep(睡眠)、suspend(挂起)等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可分为三种：等待阻塞：运行状态中的线程执行wait()方法，使线程进入到等待阻塞状态同步阻塞：线程在获取Synchronized同步锁失败（因为同步锁被其他线程占用）其他阻塞：通过调用线程的sleep()或join()发出了I/O请求时，线程就会进入到阻塞状态。当sleep()状态超时，join()等待线程终止或超时，或者I/O处理完毕，线程重新转入就绪状态。死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。3、线程的优先级每一个java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java线程的优先级是一个整数，取值范围是1-10默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY(5).具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。创建一个线程4、Java 提供了三种创建线程的方法：通过实现 Runnable 接口；通过继承 Thread 类本身；通过 Callable 和 Future 创建线程。 //继承Thread类 package com.group.demo2019525; public class MyThread extends Thread{ private String name; public MyThread(String name) { this.name=name; } @Override public void run() { // TODO Auto-generated method stub for(int i = 10 ; i &gt;0 ; i --) { System.out.println(name+&quot;执行&quot;+i); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } //实现Runnable接口 package com.group.demo2019525; public class MyThread2 implements Runnable{ private String name; public MyThread2(String name) { this.name = name; } @Override public void run() { // TODO Auto-generated method stub for(int i =0; i &lt; 10; i++) { System.out.println(name+&quot;执行了&quot;+i); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } package com.group.demo2019525; public class MyTest { public static void main(String[] args) { MyThread mythread1 = new MyThread(&quot;A&quot;); mythread1.start(); new Thread(new MyThread2(&quot;B&quot;)).start();; } } 5、Thread和Runnable的差别实现Runable接口比继承Thread类所具有的优势：1、适合多个同样的程序代码的线程去处理同一个资源2、能够避免java中的单继承的限制3、添加程序的健壮性，代码能够被多个线程共享，代码和数据独立4、线程池仅仅能放入实现Runable或callable类线程，不能直接放入继承Thread的类 6、多线程不安全例子 //吃苹果案例 package com.group.demo2019525; public class ThreadProblem implements Runnable { private int num = 10; @Override public void run() { for (int i = 0; i &lt; 10; i++) { if(num &gt; 0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;吃了编号为&quot;+num+&quot;的苹果&quot;); num--; } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } package com.group.demo2019525; public class MyTest { public static void main(String[] args) { ThreadProblem tp = new ThreadProblem(); new Thread(tp,&quot;A&quot;).start(); new Thread(tp,&quot;B&quot;).start(); } } B吃了编号为20的苹果A吃了编号为20的苹果A吃了编号为18的苹果B吃了编号为18的苹果B吃了编号为16的苹果A吃了编号为16的苹果B吃了编号为14的苹果A吃了编号为14的苹果A吃了编号为12的苹果B吃了编号为12的苹果B吃了编号为10的苹果A吃了编号为10的苹果A吃了编号为8的苹果B吃了编号为8的苹果B吃了编号为6的苹果A吃了编号为6的苹果B吃了编号为4的苹果A吃了编号为4的苹果A吃了编号为2的苹果B吃了编号为1的苹果A吃了编号为0的苹果 线程安全问题产生的原因：1、多个线程在操作共享的数据。2、操作共享数据的线程代码有多条。3、当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。 7、解决思路:就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。在java中，用同步代码块就可以解决这个问题。同步代码块的格式 package com.group.demo2019525; public class ThreadProblem implements Runnable { private int num = 20; @Override public void run() { for (int i = 0; i &lt; 20; i++) { synchronized (ThreadProblem.class) { if(num &gt; 0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;吃了编号为&quot;+num+&quot;的苹果&quot;); --num; } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } }]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F01%2F12%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[历史Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。简单的实例来展示 Java 编程，创建文件 HelloWorld.java(文件名需与类名一致), 代码如下： public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello World&quot;); } } 运行以上实例，输出结果如下：这是命令行下操作 $ javac HelloWorld.java $ java HelloWorld 结果如下 Hello World 执行命令解析：以上我们使用了两个命令 javac 和 java。javac 后面跟着的是java文件的文件名，例如 HelloWorld.java。 该命令用于将 java 源文件编译为 class 字节码文件，如： javac HelloWorld.java。运行javac命令后，如果成功编译没有错误的话，会出现一个 HelloWorld.class 的文件。java 后面跟着的是java文件中的类名,例如 HelloWorld 就是类名，如: java HelloWorld。 注意：java命令后面不要加.class。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2019%2F01%2F05%2F%E7%94%A8hexo%E6%90%AD%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[配置本地环境1、下载安装这两个软件 Git-2.21.0-64-bit.exe node-v10.15.3-x64.msi 如下图 2、在自己电脑某个盘里新建一个文件夹(自定义名称) 我的文件夹名称为 czjblog 3、然后在文件夹里，右键—&gt;选择Git Bash Here 就打开另一个窗口了，如下图 4、安装hexo 用命令 npm install hexo –g 如果网络好的话很快就行了 5、检查一下是否安装成功 用命令 hexo –v 出现以下图说明成功了 6、初始化自己创建的文件夹 用命令 hexo init 7、生成静态页面 用命令 hexo g 8、启动项目 用命令 hexo s 出现如下图说明启动成功 去浏览器输入 http://localhost:4000 来访问了. 配置github环境1、 首先得去github官网上面去注册一个账号 2、 然后新建一个仓库依赖，如下图 3、 然后来到这页面，如下图 https://github.com/caozhongjue/caozhongjue.github.io.git git@github.com:caozhongjue/caozhongjue.github.io.git 4、然后修改本地博客目录的配置： 修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： type: git repository: git@github.com:caozhongjue/caozhongjue.github.io.git //caozhongjue换为自己的 branch: master 5、控制台命令：npm install –save hexo-deployer-git //安装部署插件 6、由于我是用ssh 与github关联的，所以得操作这步，输入命令 ssh-keygen -t rsa -C “2857113935@qq.com” 连续回车三下生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）如下图 7、经过上面的步骤，在C:\Users\Administrator.ssh下面生成了一个id_rsa.pub文件，把里面的内容复制到 github ssh安全那里，如下面 标题随便填，键是id_rsa.pub文件里面的内容。 8、可以使用hexo d 发布项目到github上面去了 如下图 更改默认主题样式Next主题的使用说明 http://theme-next.iissnan.com/getting-started.html 1、 使用命令 git clone https://github.com/iissnan/hexo-theme-next 2、 修改项目目录下_config.yml文件内容，把theme：后面的内容换为next theme: hexo-theme-next #修改网站主题样式 title: czj’blog # author: czj #修改作者 language: zh-Hans #修改网站的显示语言，这里是中文 3、 修改项目目录下hexo-theme-next 主题下的_config.yml文件内容， menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive上面这几个就是下面的 1、添加分类模块 命令如下 hexo new page categories 你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为 title: 分类 3、打开 主题配置文件 找到menu，将categorcies取消注释 4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子： title: 分类测试文章标题 categories: 分类名 添加标签模块 命令hexo new page tags 同上 添加关于模块 命令hexo new page about 同上 highlight_theme: night bright #代码的样式 avatar: https://s2.ax1x.com/2019/05/23/VPZiAe.png #设置头像 4、 添加搜索功能 4.1、安装 hexo-generator-searchdb 插件 npm install hexo-generator-searchdb –save 4.2、打开 站点配置文件 找到Extensions在下面添加 search: path: search.xml field: post format: html limit: 100004.3、打开 主题配置文件 找到Local search，将enable设置为true 5、修改文章内链接文本样式 打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 6、首页的文章只显示一半用文本编辑器打开 themes/next 目录下的 _config.yml 文件，找到这段代码： auto_excerpt: enable: false length: 150把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。 修改后重启 hexo 就ok了。 项目的目录结构 source 文件夹存放着用markdown编辑器写的章 每次添加文章都是用markdown编辑器写好保存，放到source下面的_post文件夹下面去themes 这里存放着样式_config.yml 主站点配置文件 ，themes样式文件夹下面的文件夹里也有个样式配置文件可以使用MarkdownPad2编辑器写文章，写完后，把那个.md文章放到source下的_post文件夹下，然后右键打开窗口， 依次使用命令 hexo clean , hexo g ,hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
