<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[认识vue]]></title>
    <url>%2F2019%2F06%2F10%2Fvue%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是vue1、vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用，Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。2、创建一个 .html 文件，然后通过如下方式引入 Vue： &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 或者： &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 声明式渲染&lt;div id=&quot;app&quot;&gt; {{msg}} &lt;h4 v-text=&quot;msg&quot;&gt;aaaa&lt;/h4&gt; &lt;span v-html=&quot;msg2&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el: &apos;#app&apos;, data: { msg: &quot;你好 vue&quot;, msg2: &quot;&lt;h2&gt;helloworld&lt;/h2&gt;&quot; } }) &lt;/script&gt; 除了文本插值，我们还可以像这样来绑定元素特性： &lt;div id=&quot;app-2&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;/div&gt; var app2 = new Vue({ el: &apos;#app-2&apos;, data: { message: &apos;页面加载于 &apos; + new Date().toLocaleString() } }) v-bind 没法实现双向绑定，v-model可以 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{msg5}}&lt;/p&gt; &lt;input type=&quot;text&quot; style=&quot;width: 100%;&quot; v-model=&quot;msg5&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el: &apos;#app&apos;, data: { msg5: &quot;大家都是好学生，爱代码，爱学习&quot; }, methods: { } }) &lt;/script&gt; v-bind 特性被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性。 事件机制&lt;div id=&quot;app&quot;&gt; &lt;button name=&quot;按钮&quot; value=&quot;按钮&quot; v-on:click=&quot;show&quot;&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el: &apos;#app&apos;, data: { }, methods: { show: function () { alert(&quot;你好啊&quot;) } } }) &lt;/script&gt; 案例&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;浪起来&quot; @click=&quot;lang&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;别浪&quot; @click=&quot;stop&quot;&gt; &lt;p&gt;{{msg4}}&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el: &apos;#app&apos;, data: { msg4: &quot;猥琐发育别浪&quot;, intervalId: null }, methods: { lang: function () { var _this = this; if(this.intervalId !=null){ return ; }else{ } this.intervalId = setInterval(function () { var start = _this.msg4.substring(0,1); var end = _this.msg4.substring(1); _this.msg4 = end+start; },400) }, stop: function () { clearInterval(this.intervalId); this.intervalId =null; } } }) &lt;/script&gt; 条件与循环&lt;div id=&quot;app-3&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt; &lt;/div&gt; var app3 = new Vue({ el: &apos;#app-3&apos;, data: { seen: true } }) 还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表： &lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; {{ todo.text }} &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; var app4 = new Vue({ el: &apos;#app-4&apos;, data: { todos: [ { text: &apos;学习 JavaScript&apos; }, { text: &apos;学习 Vue&apos; }, { text: &apos;整个牛项目&apos; } ] } }) 处理用户输入为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法： &lt;div id=&quot;app-5&quot;&gt; &lt;p&gt;{{ message }}&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt; &lt;/div&gt; var app5 = new Vue({ el: &apos;#app-5&apos;, data: { message: &apos;Hello Vue.js!&apos; }, methods: { reverseMessage: function () { this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) } } }) 组件化应用构建组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单： // 定义名为 todo-item 的新组件 Vue.component(&apos;todo-item&apos;, { template: &apos;&lt;li&gt;这是个待办项&lt;/li&gt;&apos; }) 现在你可以用它构建另一个组件模板： &lt;ol&gt; &lt;!-- 创建一个 todo-item 组件的实例 --&gt; &lt;todo-item&gt;&lt;/todo-item&gt; &lt;/ol&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux配置java环境]]></title>
    <url>%2F2019%2F03%2F16%2Flinux%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[centos安装jdk服务器阿里云 系统centos 连接工具secure crt上传文件 打开sftpsecure crt打开sftp，file–&gt;Connect Sftp Session(快捷键 alt+p)上传jdk,直接拖jdk压缩包到sftp那个窗口就行了，等上传完全用tar命令解压开文件 tar -zxvf jdk-8u201-linux-x64.tar.gz 重命名解压后的文件夹 mv jdk-8u201-linux-x64 jdk8 配置环境变量,编辑profile文件 vi /etc/profile 加入下面内容，/root/jdk8是jdk的安装路径 export JAVA_HOME=/root/jdk8 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 执行命令,使配置文件生效 source /etc/profile 查看命令,如下图 java -version javac -version centos安装mysql下载并安装MySQL官方的 Yum Repository wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。 yum -y install mysql57-community-release-el7-10.noarch.rpm 之后就开始安装MySQL服务器。 yum -y install mysql-community-server MySQL数据库设置 首先启动MySQL systemctl start mysqld.service 查看MySQL运行状态，运行状态如图： systemctl status mysqld.service 此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码： grep &quot;password&quot; /var/log/mysqld.log 如下命令进入数据库： mysql -u root -p 输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库： ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;gznc865958&apos;; (gznc865958是自己设置的)这里有个问题，新密码设置的时候如果设置的过于简单会报错： 密码的长度是由validate_password_length决定的，而validate_password_length的计算公式是： validate_password_length = validate_password_number_count + validate_password_special_char_count + (2 * validate_password_mixed_case_count) 我的是已经修改过的，初始情况下第一个的值是ON，validate_password_length是8。可以通过如下命令修改： set global validate_password_policy=0; set global validate_password_length=1; 设置 MySQL 的字符集为 UTF-8：打开 /etc 目录下的 my.cnf 文件（此文件是 MySQL 的主配置文件）： vim /etc/my.cnf 在 [mysqld] 前添加如下代码： [client] default-character-set=utf8 在 [mysqld] 后添加如下代码： character_set_server=utf8 重启mysql后 再登录，看看字符集，6个utf8就算OK show variables like &apos;%character%&apos;; centos安装tomcat上传tomcat,直接拖tomcat压缩包到sftp那个窗口就行了，等上传完全用tar命令解压开文件 tar -zxvf apache-tomcat-7.0.90.tar.gz 重命名解压后的文件夹 mv apache-tomcat-7.0.90 tomcat centos安装nginx1、需要安装gcc的环境。 yum install gcc-c++ 2、第三方的开发包。 yum install -y pcre pcre-devel yum install -y zlib zlib-devel yum install -y openssl openssl-devel 第一步：把nginx的源码包上传到linux系统第二步：解压缩，改文件夹名 tar zxf nginx-1.8.0.tar.gz mv nginx-1.8.0 nginx1.8 第三步：进入到nginx1.8文件中 使用configure命令创建一makeFile文件。 ./configure \ --prefix=/usr/local/nginx \ --pid-path=/var/run/nginx/nginx.pid \ --lock-path=/var/lock/nginx.lock \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --with-http_gzip_static_module \ --http-client-body-temp-path=/var/temp/nginx/client \ --http-proxy-temp-path=/var/temp/nginx/proxy \ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \ --http-scgi-temp-path=/var/temp/nginx/scgi 注意：启动nginx之前，上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录 mkdir /var/temp/nginx/client -p 第四步： make 第五步： make install 启动nginx进入nginx下面的sbin目录 ./nginx 查看进程 netstat -ano|grep 80 ps -ef|grep nginx 在浏览器输入主机ip加端口80,如下图关闭nginx： ./nginx -s stop 推荐使用： ./nginx -s quit 重启nginx： 1、先关闭后启动。 2、刷新配置文件： ./nginx -s reload 配置nginx反向代理 进入nginx下的conf目录下， vi nginx.conf upstream tomcatserver1{ server 119.23.17.96:8080; } server { listen 80; server_name blog.caozhongjue.top; location / { proxy_pass http://tomcatserver1; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 启动tomcat进入到tomcat的bin目录中 ./startup.sh关闭tomcat ./shutdown.sh 查看日志 cd .. cd logs tail -f catalina.out]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr]]></title>
    <url>%2F2019%2F03%2F09%2Fvultr%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、vultr的官网在vultr的官网注册自己的账号，充钱进入到自己的个人页面点那个蓝色+号,选择好自己的实例服务器地区，系统，每月扣标准，最后点 deploy now2、创建好自己的实例，打开终端控制台如下图，输root账户,密码开放端口 80 22 88913、我这Secure crt工具连4、搭建vps服务器，命令如下 wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 在输入第3条命令后 会要你选择加密方式，我直接按7回车，再回车，（为什么选7呢）因为客户端也有对应的解密方式，两者要对应出现下图才下载成功5、命令查看服务有没有启动 lsof -i:8891 如果提示命令找不到，就安装一下lsof命令 yum install lsof -y 6、先把服务干掉 kill -9 16375 （16375是进程id） 启动服务命令 ssserver -c /etc/shadowsocks.json &amp; （我用secure crt工具连服务器，每次断开后，vps服务就挂了，我添加自启动）先看看ssserver命令存放在用命令 which ssserver 我的存放在/usr/bin/ssserver下 vi /etc/rc.local 打rc.local文件在里面加这个内容 /usr/bin/ssserver -c/etc/shadowsocks.json -d start 执行下命令 chmod 777 /etc/rc.local reboot 7、最后一步，使用代理客户端shadowsocks-win-2.3（自行百度）8、打开这个工具，输入自己的服务器的ip地址，刚刚设置的端口号和密码，如果不记得了，去打开/etc/shadowsocks.json文件，里面有端口和密码9、最后访问google官网看看]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vultr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot初识]]></title>
    <url>%2F2019%2F03%2F02%2Fspringboot%2F</url>
    <content type="text"><![CDATA[什么是Spring Boot随着动态语言的流行（Ruby、Groovy、Scala、Node.js），Java的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部暑流程以及第三方技术集成难度大。 在这样的环境下，Spring Boot应运而生。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须手动进行配置）的理念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立（运行jar，内嵌Servlet容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring 配置。 Spring Boot优缺点优点（1）快速构建项目;（2）对主流开发框架的无配置集成;（3）项目可独立运行，无须外部依赖Servlet容器；（4）提供运行时的应用监控；（5）极大地提高了开发、部署效率；（6）与云计算的天然集成。缺点（1）书籍文档较少且不够深入（2）如果你不认同Spring框架，这也许是它的缺点 创建一个超级简单的的Springboot项目工具:ideamaven目录结构如下pom.xml文件内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.caozhongjue&lt;/groupId&gt; &lt;artifactId&gt;myblog&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 创建一个Controller类 package com.caozhongjue.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; /** * @author 曹忠爵 * @site * @create 2019-06-30 14:17 */ @Controller public class index { @RequestMapping(&quot;/&quot;) @ResponseBody public String index(){ return &quot;helloworld&quot;; } } 创建一个启动类 package com.caozhongjue; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.context.annotation.ComponentScan; /** * @author 曹忠爵 * @site * @create 2019-06-30 15:13 */ //@SpringBootApplication @EnableAutoConfiguration @ComponentScan(&quot;com.caozhongjue.controller&quot;) public class MBSpringBootApplication { public static void main(String[] args){ SpringApplication.run(MBSpringBootApplication.class); } } @SpringBootApplication这个注解相当于@EnableAutoConfiguration+@ComponentScan这两个注解两个注解都能启动SpringBoot项目 springboot整合jdbc目录结构 添加jdbc mysql驱动依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; application.yml文件 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: gznc865958 server: port: 8888 创建Person类 package com.caozhongjue.entity; /** * @author 曹忠爵 * @site * @create 2019-06-30 17:14 */ public class Person { private Integer id; private String name; private String sex; private Integer age; private String des; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getDes() { return des; } public void setDes(String des) { this.des = des; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } PersonController类 package com.caozhongjue.controller; import com.caozhongjue.entity.Person; import com.caozhongjue.service.PersonService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author 曹忠爵 * @site * @create 2019-06-30 19:55 */ @RestController @RequestMapping(&quot;/person&quot;) @ComponentScan(&quot;com.caozhongjue.service&quot;) public class PersonController { @Autowired private PersonService personService; @RequestMapping(&quot;/add&quot;) public String add(Person person){ return personService.add(person); } } PersonService接口 package com.caozhongjue.service; import com.caozhongjue.entity.Person; /** * @author 曹忠爵 * @site * @create 2019-06-30 20:00 */ public interface PersonService { public String add(Person person); } PersonServiceImpl类 package com.caozhongjue.service.impl; import com.caozhongjue.entity.Person; import com.caozhongjue.service.PersonService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Service; /** * @author 曹忠爵 * @site * @create 2019-06-30 20:01 */ @Service public class PersonServiceImpl implements PersonService { @Autowired private JdbcTemplate jdbcTemplate; @Override public String add(Person person) { String sql = &quot;insert into person (id,name,sex,age,des) values(null,?,?,?,?)&quot;; int effectCount=jdbcTemplate.update(sql,person.getName(),person.getSex(),person.getAge(),person.getDes()); return effectCount&gt;0?&quot;插入成功&quot;:&quot;失败了&quot;; } } @Resource与@Autowired用法区别spring中，@Resource和@Autowired都是做bean的注入时使用。使用过程中，有时候@Resource 和 @Autowired可以替换使用；有时，则不可以。 共同点@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。 不同点 @Resource是Java自己的注解，@Resource有两个属性是比较重要的，分是name和type；Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Autowired是spring的注解，是spring2.5版本引入的，Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。 springboot整合spring data jpa添加spring data jpa依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; application.yml文件 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: gznc865958 jpa: database: mysql show-sql: true hibernate: ddl-auto: update server: port: 8888 创建Student类 package com.caozhongjue.entity; import javax.persistence.*; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:12 */ @Entity public class Student { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String name; @Column private String sex; @Column private String age; @Column private String grade; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } public String getGrade() { return grade; } public void setGrade(String grade) { this.grade = grade; } } StudentController类 package com.caozhongjue.controller; import com.caozhongjue.entity.Student; import com.caozhongjue.service.StudentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:56 */ @RestController @RequestMapping(&quot;/student&quot;) public class StudentController { @Autowired private StudentService studentService; @RequestMapping(&quot;/add&quot;) public String add(Student student){ return studentService.add(student); } } StudentService接口 package com.caozhongjue.service; import com.caozhongjue.entity.Student; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:51 */ public interface StudentService { public String add(Student student); } StudentServiceImpl类 package com.caozhongjue.service.impl; import com.caozhongjue.entity.Student; import com.caozhongjue.mapper.StudentMapper; import com.caozhongjue.service.StudentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:52 */ @Service public class StudentServiceImpl implements StudentService { @Autowired private StudentMapper studentMapper; @Override public String add(Student student) { Student stu = studentMapper.save(student); return null; } } StudentMapper接口 package com.caozhongjue.mapper; import com.caozhongjue.entity.Student; import org.springframework.data.jpa.repository.JpaRepository; /** * @author 曹忠爵 * @site * @create 2019-06-30 21:50 */ public interface StudentMapper extends JpaRepository&lt;Student,Integer&gt; { } spring boot整合 mybatis添加依赖 dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux centos]]></title>
    <url>%2F2019%2F02%2F23%2Flinux%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[linux各个版本根据用途不同可以做如下划分：(1)家庭用途可选择版本有：Linux Mint、Ubuntu(2)商业用途可选择版本有：Debian、RHEL、CentOS(3)挑战用途可选择版本有：Gentoo、LFS(4)理想用途可选择版本有：FreeBSD、OpenBSD、Solaris、OpenSolaris redhat、centos下载地址(1)redhat(2)centos选择dvd是比较全面的，centos minimal iso是字符界面的，没图形界面的 配置网络目录路径 /etc/sysconfig/network-scripts我的网卡是ifcfg-ens33用命令 vi ifcfg-ens33打开这个文件BOOTPROTO修改为dhcpONBOOT修改为yes重启网卡命令 service network restart 查看ip的命令 ip addr 或 ifconfigcentos7没有ifconfig命令得安装 yum install net-tools -y 配置DNS路径 /etc/ vi resolv.conf centos7 防火墙 firewalled关闭防火墙 systemctl stop firewalld开启防火墙 systemctl start firewalld重启防火墙 systemctl restart firewalld或关闭防火墙 service firewalld stop开启防火墙 service firewalld start重启防火墙 service firewalld restartcentos6 防火墙 iptables想直接执行最后一次命令直接!号加命令首写 如!ser 等于最后一次命令 service firewalld restart 查看firewall是否运行,下面两个命令都可以 systemctl status firewalld.service firewall-cmd --state 查看当前开了哪些端口其实一个服务对应一个端口，每个服务对应/usr/lib/firewalld/services下面一个xml文件。 firewall-cmd --list-services 查看所有打开的端口： firewall-cmd --zone=public --list-ports 添加开放端口 firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） 重新载入 firewall-cmd --reload 查看 firewall-cmd --zone= public --query-port=80/tcp 删除 firewall-cmd --zone= public --remove-port=80/tcp --permanent (命令如下图 注意是有两个-的) 常用命令1、linux文件目录linux根目录 /存放必要的命令 /bin存放内核以及启动所需要的文件 /boot存放硬件设备文件 /dev存放系统配置文件 /etc 普通用户宿主目录 /home存放必要的运行库 /lib超级用户的主目录 /root存放系统管理程序 /sbin存放临时的映射文件系统,通常用来挂载使用 /mnt存放临时文件 /tmp存放应用程序 /usr 命令行中# 代表是管理员身份命令行中$ 代表是普通用户身份 2、命令linux查看当前目录有哪些内容 ls linux查看当前目录有哪些内容详情 ls -l 查看当前位置 pwd 去下一级目录 cd 下一级目录 返回上一级目录 cd .. 清屏 clear 创建文件命令 touch a.txt 创建目录 mkdir 直接同时创建文夹件里再创文件夹 mkdir -p 如下图删除目录,只能删除为空的一个目录，rmdir 后面跟要删的文件夹名 rmdir 这个能删除一个文件夹里面的文件夹，上下级一起删，如下图，如果abc下有多个文件夹，则删不了全部 rmdir -p 删除命令 rm rm -r -f 删除某个文件或文件夹，不管文件夹有没有东西，参数 r 表示递归， f 表示强制删 移动命令 mv mv命令,也可以用来重命名文件，如 mv a.txt b.txt 复制命令,有覆盖内容的作用 cp abcd/a.txt abcde/b.txt cp命令 要复制目录得 用参数 r 查看文件内容命令cat直接查看全部内容，参数n显示行号 cat head查看文件内容头10行 head tail查看文件内容尾10行，tail -f 表示实时显示， tail -fn -10 表示查看实时行数 tail more查看百分几，回车继续显示 more less按屏幕大小显示，按上下键继续显示 less echo命令一个 &gt; 表示覆盖二个 &gt; 表示追加 echo &quot;aaa&quot; &gt; b.txt echo &quot;bbb&quot; &gt;&gt; b.txt 查看端口被哪个进程占用命令 netstat、ps、lsof netstat -lnp|grep 8080 或netstat -ano|grep 8080 netstat命令选项：-a all 默认不显示LISTEN相关-t tcp-u udp-n number 不显示别名，能显示数字的都用数字显示。由于不需要把数字转换成别名，所以显示的快一些-l listen 仅列出正在监听的服务状态-p program 显示建立连接的程序名-r route 路由信息-e extention 扩展信息，比如uid等-s statistic 按各个协议进行统计-c cycle 每隔一段时间周期执行netstat命令 ps -ef|grep java或ps -aux|grep java ps命令选项： 1）ps aa 显示现行终端机下的所有程序，包括其他用户的程序。2）ps -A 显示所有程序。3）ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。4）ps -e 此参数的效果和指定”A”参数相同。5）ps e 列出程序时，显示每个程序所使用的环境变量。6）ps f 用ASCII字符显示树状结构，表达程序间的相互关系。7）ps -H 显示树状结构，表示程序间的相互关系。8）ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。9）ps s 采用程序信号的格式显示程序状况。10）ps S 列出程序时，包括已中断的子程序资料。11）ps -t&lt;终端机编号&gt; 指定终端机编号，并列出属于该终端机的程序的状况12）ps u 以用户为主的格式来显示程序状况。 lsof -i:8080 lsof命令常用选项： lsof filename 显示打开指定文件的所有进程lsof -a 表示两个参数都必须满足时才显示结果lsof -c string 显示COMMAND列中包含指定字符的进程所有打开的文件lsof -u username 显示所属user进程打开的文件lsof -g gid 显示归属gid的进程情况lsof +d /DIR/ 显示目录下被进程打开的文件lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长lsof -d FD 显示指定文件描述符的进程lsof -n 不将IP转换为hostname，缺省是不加上-n参数lsof -i 用以显示符合条件的进程情况 window系统查看进程 netstat -ano 查看被占用端口对应的PID语法格式：netstat -ano | findstr “端口号” netstat -ano | findstr &quot;8080&quot; 最后一位数字就是PID，这里是9736taskkill（结束进程）强制（/F参数）杀死pid为8112的所有进程包括子进程（/T参数） taskkill /T /F /PID 9736 也可小写 taskkill /f /t /PID 9736 关机 shutdown 现在关机 shutdown now 重启 reboot rpm 安装软件yum 安装软件secure crt上传下载文件一、rz sz方式 1、linux服务器大多是通过ssh客户端来进行远程的登陆和管理的，使用ssh登陆linux主机以后，如何能够快速的和本地机器进行文件的交互呢，也就是上传和下载文件到服务器和本地；与ssh有关的两个命令可以提供很方便的操作：sz：将选定的文件发送（send）到本地机器rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到服务器(receive)注意：sz中的s意为send（发送），告诉客户端，我（服务器）要发送文件 send to cilent，就等同于客户端在下载。rz中的r意为received（接收），告诉客户端，我（服务器）要接收文件 received by cilent，就等同于客户端在上传2、如果linux上没有这两个命令工具，则需要先安装。可以使用yum安装。运行命令 yum install lrzsz。 3、使用条件普通Linux和Windows之间的文件共享方法，主要有建立nfs实现文件共享，和tftp之类的方法，但是都很麻烦，而如果只是小文件（几十 K，几百K），那么直接用rz/sz，就显得极其地方便了。4、如何使用从windows中拷贝/下载文件到Linux（开发板）： 运行rz后，会自动弹出WIndows下的文件选择对话框，选择对应文件后，添加，然后确定，就开始传输，将windows中的文件，拷贝到Linux中了。 将Linux中的文件拷贝到Windows中某个文件夹： 执行sz file_name 就可以将Linux当前文件夹下的文件file_name拷贝到Windows的对应目录中了，其中，Windows目录是由你当前运行的工具中设定的。 此处我用的是SecureCRT，具体的更改 rz上传/sz下载 的默认的路径的方法： 右键点击当前会话session -&gt; Session Options -&gt; Terminal -&gt; Xmodem/Zmodem -&gt;Directories : Upload : 你要设置的路径Download:你要设置的路径 二、sftp 1、为了数据和服务的安全, 很多生产环境中的Linux服务器不能使用外网环境. 在只有SSH连接的情况下, 传输文件变得很不方便.如果Linux服务器未安装用于上传和下载的lrzsz软件, 又不能现场安装, 此时可考虑使用sftp完成相关操作.SFTP是Secure File Transfer Protocol(安全文件传输协议)的缩写, 可以为传输文件提供一种安全的网络的加密方法. 不需要单独安装或配置sftp —— 支持SSH连接的服务器, 也就默认开启了SFTP. 2、SFTP与FTP的区别FTP是一种方便数据共享的文件传输协议, 包括一个FTP服务器和多个FTP客户端. FTP客户端通过FTP协议从服务器上下载资源.SFTP协议是在FTP的基础上, 对数据采取了加密/解密技术, 使数据传输更安全.SFTP的传输效率比FTP的低很多. (1) 软件环境:可以使用任意终端工具, 比如MacOS下的Terminal, 或iTerm(此处演示使用), 或SecureCRT.(2) sftp建立连接:在终端中进行操作, 若打开SecureCRT的sftp: 菜单栏的[File] –&gt; [Connect SFTP Session]即可.在默认的SSH端口(22)下连接:sftp username@remote_ip(or remote host name), 连接root用户, 则可省略”root@”. sftp root@119.23.17.96 在其他端口下的连接 sftp -o port=1000 username@remote_ip 如果出现验证, 填入正确的密码后即可实现远程连接. 连接成功后终端信息如图: sftp - 上传文件sftp与ftp有着几乎相同的语法和功能: ① ls, rm, cd, mkdir, pwd 等指令是对当前连接的远程端服务器的操作; ② lls, lrm, lcd, lmkdir, lpwd 等指令是对本地端服务器的操作 —— 在上述指令前加l(local)即可. 上传操作示例:默认连接的都是root目录, 查看本地和远端/root路径下的文件: sftp&gt; lls # 本地 anaconda-ks.cfg install.log install.log.syslog porc remote.sh test.sh sftp&gt; ls # 远端 anaconda-ks.cfg install.log install.log.syslog myid remote.sh test.sh 将本地的remote.sh文件上传至远端服务器的/home路径下: sftp&gt; put -r &quot;F:\压缩包\apache-tomcat-7.0.90.tar.gz&quot; Uploading apache-tomcat-7.0.90.tar.gz to /root/apache-tomcat-7.0.90.tar.gz sftp&gt; ls /root # 查看远端/root路径下的文件 /root/apache-tomcat-7.0.90.tar.gz sftp - 下载文件下载操作示例:将远端/root路径下的myid文件下载至本地/home路径下: sftp&gt; get -r /root/apache-tomcat-7.0.90.tar.gz Fetching /root/apache-tomcat-7.0.90.tar.gz to C:\Users\Administrator\Documents sftp&gt; lls # 查看本地路径下的文件]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识c++]]></title>
    <url>%2F2019%2F02%2F16%2Fc%2B%2B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C++ 简介C++是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。C++被认为是一种中级语言，它综合了高级语言和低级语言的特点。C++是由Bjarne Stroustrup于1979年在新泽西州美利山贝尔实验室开始设计开发的，扩充和完善了C语言，最初命名为带类的C，后来更改为C++。 C++完全支持面向对象的程序设计，包括面向对象开发的四大特性：1、封装2、数据隐藏3、继承4、多态 标准库标准的c++由三个重要部分组成 ：1、核心语言，提供了所有构件块，包括变量、数据类型和常量。2、C++标准库，提供了大量的函数，用于操作文件、字符串等。3、标准模板库(STL)，提供了大量的方法，用于操作数据结构等。 环境设置本地环境如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。文本编辑器：名称和版本在不同操作系统上可能会有所不同，如notepad.exe(普通记事本)、notepad++.exe、editplus等用于windows操作系统。vim和vi可用于windows和linux/unix操作系统。通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。C++ 编译器：写在源文件中的源代码是人类可读的源。它需要”编译”，转为机器语言，这样 CPU 可以按给定指令执行程序。C++ 编译器用于把源代码编译成最终的可执行程序，最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。 Windows 上的安装GUN的gcc 编译器：为了在 Windows 上安装 GCC，您需要安装 MinGW。添加您安装的 MinGW 的 bin 子目录到您的 PATH 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。编写C++的集成开发工具有vs 2008、codeblocks、dev-c++等。 C++ 基本语法1、C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。对象 - 对象具有状态和行为。类 - 类可以定义为描述对象行为/状态的模板方法 - 从基本上说，一个方法表示一种行为。即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。2、C++ 程序结构 #include &lt;iostream&gt; using namespace std; // main() 是程序开始执行的地方 int main() { cout &lt;&lt; &quot;你好,c++&quot; &lt;&lt; endl; return 0; } 2.1、C++语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。这段程序中，包含了头文件。2.2、行using namespace std;告诉编译器使用std命名空间。命名空间是C++中相对新的概念。2.3、main()是程序开始执行的地方，//是一个单行注释。2.4、int main()是主函数，程序从这里开始执行。2.5、cout &lt;&lt;”你好，c++”;会在屏幕上显示消息”Hello World”。2.6、return 0;终止main()函数，并向调用进程返回值0。 如果是用notepad记事本来编写源码，得启动命令行cmd，用g++ 文件名.cpp来译译，(前提得配置好环境变量)如下使用g++编译后，会在源文件中生成一个.exe文件。-o 这个参数 用来指定编译后的文件名。3、C++ 中的分号 &amp; 块在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。 例如，下面是三个不同的语句： x = y; y = y+1; add(x, y); 块是一组使用大括号括起来的按逻辑连接的语句。例如： { cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; } C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如： x = y; y = y+1; add(x, y); 等同于 x = y; y = y+1; add(x, y); 4、C++ 标识符C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。5、C++ 关键字下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 6、三字符组三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 三字符组 替换 ??= # ??/ \ ??&apos; ^ ??( [ ??) ] ??! | ??&lt; { ??&gt; } ??- ~ 7、C++ 注释程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。C++ 注释以 / 开始，以 / 终止。例如： /* 这是注释 */ /* C++ 注释也可以 * 跨行 */ 注释也能以 // 开始，直到行末为止。例如： #include using namespace std; main() { cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; } 当上面的代码被编译时，编译器会忽略 // prints Hello World，最后会产生以下结果： Hello World 数据类型1、数据类型使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。1.1、基本的内置类型 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 类型 位 范围 char 1个字节 -128 到 127 或者 0 到 255 unsigned char 1个字节 0 到 255 signed char 1个字节 -128 到 127 int 4个字节 -2147483648 到 2147483647 unsigned int 4个字节 0 到 4294967295 signed int 4个字节 -2147483648 到 2147483647 short int 2个字节 -32768 到 32767 unsigned short int 2个字节 0 到 65,535 signed short int 2个字节 -32768 到 32767 long int 8个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8个字节 0 to 18,446,744,073,709,551,615 float 4 个字节 +/- 3.4e +/- 38 (~7 个数字) double 8 个字节 +/- 1.7e +/- 308 (~15 个数字) long double 16 个字节 +/- 1.7e +/- 308 (~15 个数字) wchar_t 2或4个字节 1 个宽字符 typedef 声明您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称： typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： feet distance; 2、C++ 变量类型变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。 类型 描述 bool 存储值 true 或 false。 char 通常是一个八位字节（一个字节）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。 double 双精度浮点值。 void 表示类型的缺失。 wchar_t 宽字符类型。 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等2.1、C++ 中的变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; type 必须是一个有效的 C++ 数据类型，可以是 char、w_char、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明： int i, j, k; char c, ch; float f, salary; double d; 变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示： type variable_name = value; 下面列举几个实例： extern int d = 3, f = 5; // d 和 f 的声明 int d = 3, f = 5; // 定义并初始化 d 和 f byte z = 22; // 定义并初始化 z char x = &apos;x&apos;; // 变量 x 的值为 &apos;x&apos; 2.2、C++ 中的变量声明变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 #include &lt;iostream&gt; using namespace std; // 变量声明 extern int a, b; extern int c; extern float f; int main () { // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout &lt;&lt; c &lt;&lt; endl ; f = 70.0/3.0; cout &lt;&lt; f &lt;&lt; endl ; return 0; } 2.3、C++ 变量作用域作用域是程序的一个区域，一般来说有三个地方可以声明变量：在函数或一个代码块内部声明的变量，称为局部变量。在函数参数的定义中声明的变量，称为形式参数。在所有函数外部声明的变量，称为全局变量。局部变量在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量： #include &lt;iostream&gt; using namespace std; int main () { // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout &lt;&lt; c; return 0; } 全局变量在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。 全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量： #include &lt;iostream&gt; using namespace std; // 全局变量声明 int g; int main () { // 局部变量声明 int a, b; // 实际初始化 a = 10; b = 20; g = a + b; cout &lt;&lt; g; return 0; } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例： #include &lt;iostream&gt; using namespace std; // 全局变量声明 int g = 20; int main () { // 局部变量声明 int g = 10; cout &lt;&lt; g; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 10 初始化局部变量和全局变量当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char &apos;\0&apos; float 0 double 0 pointer NULL 2.4、定义常量在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。使用 const 关键字。 #define 预处理器 下面是使用 #define 预处理器定义常量的形式： #define identifier value 具体请看下面的实例： #include &lt;iostream&gt; using namespace std; #define LENGTH 10 #define WIDTH 5 #define NEWLINE &apos;\n&apos; int main() { int area; area = LENGTH * WIDTH; cout &lt;&lt; area; cout &lt;&lt; NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 const 关键字您可以使用 const 前缀声明指定类型的常量，如下所示： const type variable = value;具体请看下面的实例： #include &lt;iostream&gt; using namespace std; int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = &apos;\n&apos;; int area; area = LENGTH * WIDTH; cout &lt;&lt; area; cout &lt;&lt; NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 2.5、C++ 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。 修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned short 或 unsigned long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。 unsigned x; unsigned int y; 为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序： #include &lt;iostream&gt; using namespace std; /* * 这个程序演示了有符号整数和无符号整数之间的差别 */ int main() { short int i; // 有符号短整数 short unsigned int j; // 无符号短整数 j = 50000; i = j; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j; return 0; } 当上面的程序运行时，会输出下列结果： -15536 50000上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。 C++ 函数C++ 函数函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。 函数还有很多叫法，比如方法、子例程或程序，等等。 1、定义函数C++ 中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。函数主体：函数主体包含一组定义函数执行任务的语句。 实例以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数： // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } 函数声明函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。调用函数创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： #include &lt;iostream&gt; using namespace std; // 函数声明 int max(int num1, int num2); int main () { // 局部变量声明 int a = 100; int b = 200; int ret; // 调用函数来获取最大值 ret = max(a, b); cout &lt;&lt; &quot;Max value is : &quot; &lt;&lt; ret &lt;&lt; endl; return 0; } // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 &gt; num2) result = num1; else result = num2; return result; } 把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果： Max value is : 200 C++ 数组C++ 数组C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 1、声明数组在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ];这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下： double balance[10]; 现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。2、初始化数组在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示： double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果： double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例： balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： 数组表示 3、访问数组元素数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; 上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组： #include &lt;iostream&gt; using namespace std; #include &lt;iomanip&gt; using std::setw; int main () { int n[ 10 ]; // n 是一个包含 10 个整数的数组 // 初始化数组元素 for ( int i = 0; i &lt; 10; i++ ) { n[ i ] = i + 100; // 设置元素 i 为 i + 100 } cout &lt;&lt; &quot;Element&quot; &lt;&lt; setw( 13 ) &lt;&lt; &quot;Value&quot; &lt;&lt; endl; // 输出数组中每个元素的值 for ( int j = 0; j &lt; 10; j++ ) { cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl; } return 0; } 上面的程序使用了 setw() 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果： Element Value 0 100 1 101 2 102 3 103 4 104 5 105 6 106 7 107 8 108 9 109 C++ 基本的输入输出C++ 基本的输入输出C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。 C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 I/O 库头文件下列的头文件在 C++ 编程中很重要。 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 1、标准输出流（cout）预定义的对象 cout 是 ostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的，如下所示： #include &lt;iostream&gt; using namespace std; int main( ) { char str[] = &quot;Hello C++&quot;; cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl; } 当上面的代码被编译和执行时，它会产生下列结果： Value of str is : Hello C++ C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。 流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。 2、标准输入流（cin）预定义的对象 cin 是 istream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示： #include &lt;iostream&gt; using namespace std; int main( ) { char name[50]; cout &lt;&lt; &quot;请输入您的名称： &quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl; } 当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果： 请输入您的名称： cplusplus 您的名称是： cplusplus C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。 流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句： cin &gt;&gt; name &gt;&gt; age; 这相当于下面两个语句： cin &gt;&gt; name; cin &gt;&gt; age; C++ 指针C++ 指针学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： #include &lt;iostream&gt; using namespace std; int main () { int var1; char var2[10]; cout &lt;&lt; &quot;var1 变量的地址： &quot;; cout &lt;&lt; &amp;var1 &lt;&lt; endl; cout &lt;&lt; &quot;var2 变量的地址： &quot;; cout &lt;&lt; &amp;var2 &lt;&lt; endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： var1 变量的地址： 0xbfebd5c0 var2 变量的地址： 0xbfebd5b6 1、什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type var-name;在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： int *ip; /* 一个整型的指针 */ double *dp; /* 一个 double 型的指针 */ float *fp; /* 一个浮点型的指针 */ char *ch /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 C++ 中使用指针使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： #include &lt;iostream&gt; using namespace std; int main () { int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 也可以这样 int *ip = &amp;var 代替下面的; ip = &amp;var; // 在指针变量中存储 var 的地址 cout &lt;&lt; &quot;Value of var variable: &quot;; cout &lt;&lt; var &lt;&lt; endl; // 输出在指针变量中存储的地址 cout &lt;&lt; &quot;Address stored in ip variable: &quot;; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; &quot;Value of *ip variable: &quot;; cout &lt;&lt; *ip &lt;&lt; endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var variable: 20 Address stored in ip variable: 0xbfc601ac Value of *ip variable: 20]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven的认识]]></title>
    <url>%2F2019%2F02%2F09%2Fmaven%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[普通项目存在的问题1、假如正在eclipse下开发两个java项目A、B,其中A项目中的一些功能依赖于B项目中的某些类，如何维系这种依赖关系呢？处理方法就是手动把B项目打包成jar包，然后在A项目中导入B的jar包，B项目有所改动，都得重新导2、假设正在开发一个web小demo，要用到ssm这几个框架，我们必须手动去官网下载这些jar包，然后导入 maven到底是什么maven是一种软件项目管理工具，是基于项目对象模型，可以通过一小段描述信息来管理项目的构建。Maven的核心功能便是合理叙述项目间的依赖关系，通俗点讲，就是通过pom.xml文件的配置获取jar包，而不用手动去添加jar包，而这里pom.xml文件对于学了一点maven的人来说，就有些熟悉了。 通过groupId、artifactId、version三个属性就能定位一个jar包groupId里面指的是这个jar的包名(文件夹)artifactId里面指的是这个jar文件的名(项目名)version指的是jar包的版本名 maven的安装1、来到maven官方网站 http://maven.apache.org/download.cgi 下载对应的版本 如apache-maven-3.6.1-bin.zip这个2、把这个文件解压放到某个位置，目录结构如下bin文件夹下有maven的命令conf文件夹下有配置文件,如settings.xml3、配置环境变量，cmd命令窗口才能使用maven命令，和配jdk环境变量相似 仓库通过pom.xml中的配置，就能够获取到想要的jar包(还没讲解如何配置先需要了解一下仓库的概念)，但是这些jar是在哪里呢？仓库分为：本地仓库、第三方仓库(私服)、中央仓库1、本地仓库：Maven会将工程中依赖的构件(Jar包)从远程下载到本机一个目录下管理，每个电脑默认的仓库是在C:/Users/Administrator/.m2/repository下修改本地库位置：在maven安装目录下的conf/setting.xml文件中修改如： &lt;localRepository&gt;D:\tomcat\Repository&lt;/localRepository&gt; D:\tomcat\Repository：就是我们自己创建的本地仓库，将网上下载的所有jar包，都丢到该目录下，我们就可以直接通过maven的pom.xml文件直接拿。2、第三方仓库第三方仓库，又称为内部中心仓库，也称为私服私服：一般是由公司自己设立的，只为本公司内部共享使用。它既可以作为公司内部构件协作和存档，也可作为公用类库镜像缓存，减少在外部访问和下载的频率。（使用私服为了减少对中央仓库的访问私服可以使用的是局域网，中央仓库必须使用外网也就是一般公司都会创建这种第三方仓库，保证项目开发时，项目所需用的jar都从该仓库中拿，每个人的版本就都一样。3、中央仓库Maven内置了远程公用仓库：http://repo1.maven.org/maven2这个公共仓库是由Maven自己维护，里面有大量的常用类库，并包含了世界上大部分流行的开源项目构件。国内访问这个网站很慢，一般改为阿里云的，在maven安装目录下的conf/setting.xml文件中修改，在标签里添加下面这些内容保存如： &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; maven命令1、maven web项目结构pom.xml 核心配置src/main/java java源码src/main/resources java配置src/main/webapp myeclipse web项目中 WebRoot目录 |– WEB-INF |– web.xmlsrc/test 测试target 输出目录2、命令操作maven java或web项目编译：mvn compile –src/main/java目录java源码编译生成class （target目录下）测试：mvn test –src/test/java 目录编译清理：mvn clean –删除target目录，也就是将class文件等删除打包：mvn package –生成压缩文件：java项目#jar包；web项目#war包，也是放在target目录下安装：mvn install –将压缩文件(jar或者war)上传到本地仓库部署|发布：mvn deploy –将压缩文件上传私服 eclipse中使用maven]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java设计模式]]></title>
    <url>%2F2019%2F02%2F02%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式的分类设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、状态模式、访问模式、中介模式、解释器模式。其他类的有：并发型模式和线程池模式。 设计模式的六大原则设计模式的六大原则总原则：开闭原则开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。1、 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类折分2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。5、迪米特法则（Demeter Principle）就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。6、合成复用原则（Composite Reuse Principle）原则是尽量首先使用合成/聚合的方式，而不是使用继承。 单例设计模式单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。具体实现：1、 将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。2、 在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。3、 定义一个静态方法返回这个唯一对象。饿汉模式 package com.group.demo2019526; public class Singleton1 { //将自身实例化对象设置为一个属性，用static final修饰 private static final Singleton1 singleton1=new Singleton1(); //构造方法私有化 private Singleton1() {} //静态方返回该实例 public static Singleton1 getInstance() { return singleton1; } } 懒汉模式 package com.group.demo2019526; public class Singleton2 { //将自身实例化对象设置为一个属性，用static修饰 private static Singleton2 singleton2; //构造方法私有化 private Singleton2() {} //静态方法返回该实例 public static Singleton2 getIntance() { if(singleton2==null) { singleton2=new Singleton2(); } return singleton2; } } 这个是线程不安全的 package com.group.demo2019526; public class Singleton2 { //将自身实例化对象设置为一个属性，用static修饰 private static Singleton2 singleton2; //构造方法私有化 private Singleton2() {} //静态方法返回该实例 public static Singleton2 getIntance() { if(singleton2==null) { synchronized (Singleton2.class) { if(singleton2==null) { singleton2=new Singleton2(); } } } return singleton2; } } 多线程情形下，synchronized方法通常效率低，上面使用DCL双检查锁机制 动态代理设计模式用的最广泛的，用的最多的是 动态代理模式。动态代理：就是实现阶段不用关心代理是哪个，而在运行阶段指定具体哪个代理。 抽象主题类或者接口 package com.group.demo2019526; public interface IGamePlayer { public void login(String username,String password); public void killBoss(); public void upGrade(); } 需要被代理类： package com.group.demo2019526; public class GramePlayer implements IGamePlayer { private String name=&quot;&quot;; public GramePlayer(String name) { this.name = name; } @Override public void login(String username, String password) { // TODO Auto-generated method stub System.out.println(&quot;登录名为 &quot;+username+&quot; 进入游戏，&quot; + name + &quot; 登录成功！&quot;); } @Override public void killBoss() { // TODO Auto-generated method stub System.out.println(this.name + &quot; 击杀了Boss！&quot;); } @Override public void upGrade() { // TODO Auto-generated method stub System.out.println(this.name + &quot;升级了！&quot;); } } 动态代理处理器类： package com.group.demo2019526; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class GamePlayerInvocationHandler implements InvocationHandler{ private Object obj; public GamePlayerInvocationHandler(Object obj) { this.obj=obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // TODO Auto-generated method stub Object result =null; if(&quot;login&quot;.equalsIgnoreCase(method.getName())) { System.out.println(&quot;代理登录游戏&quot;); result=method.invoke(this.obj, args); return result; } result = method.invoke(this.obj, args); return result; } } 动态代理场景类： package com.group.demo2019526; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Test { public static void main(String[] args) { IGamePlayer gp = new GramePlayer(&quot;张三&quot;); InvocationHandler gpHander=new GamePlayerInvocationHandler(gp); ClassLoader classLoader = gp.getClass().getClassLoader(); Class&lt;?&gt;[] cls = new Class[] {IGamePlayer.class}; IGamePlayer proxyGp =(IGamePlayer) Proxy.newProxyInstance(classLoader, cls, gpHander); proxyGp.login(&quot;zhangsan&quot;, &quot;123456&quot;); proxyGp.killBoss(); proxyGp.upGrade(); } }]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序算法]]></title>
    <url>%2F2019%2F01%2F26%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序int[] a = {8,7,4,5,6,3,1,2,9,0}冒泡排序：依次比较相邻的元素。如果第一个比第二个大，就交换他们两个。针对所有的元素以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。上面那个数组的大小为10那么就循环重复9趟，每趟相邻两个数比较为9次，下一趟相邻两个数比较为8次，逐级减1以下为输出结果 7,8,4,5,6,3,1,2,9,0,7,4,8,5,6,3,1,2,9,0,7,4,5,8,6,3,1,2,9,0,7,4,5,6,8,3,1,2,9,0,7,4,5,6,3,8,1,2,9,0,7,4,5,6,3,1,8,2,9,0,7,4,5,6,3,1,2,8,9,0,7,4,5,6,3,1,2,8,9,0,7,4,5,6,3,1,2,8,0,9, 4,7,5,6,3,1,2,8,0,9,4,5,7,6,3,1,2,8,0,9,4,5,6,7,3,1,2,8,0,9,4,5,6,3,7,1,2,8,0,9,4,5,6,3,1,7,2,8,0,9,4,5,6,3,1,2,7,8,0,9,4,5,6,3,1,2,7,8,0,9,4,5,6,3,1,2,7,0,8,9, 4,5,6,3,1,2,7,0,8,9,4,5,6,3,1,2,7,0,8,9,4,5,3,6,1,2,7,0,8,9,4,5,3,1,6,2,7,0,8,9,4,5,3,1,2,6,7,0,8,9,4,5,3,1,2,6,7,0,8,9,4,5,3,1,2,6,0,7,8,9, 4,5,3,1,2,6,0,7,8,9,4,3,5,1,2,6,0,7,8,9,4,3,1,5,2,6,0,7,8,9,4,3,1,2,5,6,0,7,8,9,4,3,1,2,5,6,0,7,8,9,4,3,1,2,5,0,6,7,8,9, 3,4,1,2,5,0,6,7,8,9,3,1,4,2,5,0,6,7,8,9,3,1,2,4,5,0,6,7,8,9,3,1,2,4,5,0,6,7,8,9,3,1,2,4,0,5,6,7,8,9, 1,3,2,4,0,5,6,7,8,9,1,2,3,4,0,5,6,7,8,9,1,2,3,4,0,5,6,7,8,9,1,2,3,0,4,5,6,7,8,9, 1,2,3,0,4,5,6,7,8,9,1,2,3,0,4,5,6,7,8,9,1,2,0,3,4,5,6,7,8,9, 1,2,0,3,4,5,6,7,8,9,1,0,2,3,4,5,6,7,8,9, 0,1,2,3,4,5,6,7,8,9, 代码如下 package com.group.demo2019524; /** * @author Administrator */ public class BubbleSort { void sort(int[] a) { for(int i =0;i &lt; a.length-1 ; i++) { for(int j =0;j &lt; a.length-1-i ; j++) { int temp ; if(a[j]&gt;a[j+1]) { temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } } public static void main(String[] args) { int[] a = {8,7,4,5,6,3,1,2,9,0} ; System.out.println(&quot;排序前：&quot;); for(int array :a) { System.out.print(array); } new BubbleSort().sort(a); System.out.println(&quot;\n排序后：&quot;); for(int array :a) { System.out.print(array); } } } 结果如下 排序前：8745631290排序后：0123456789 快速排序原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。传入getIndex (int arr[], int start, int end)的为数组arr[]、数组最初的下标起点和下标终点，而数组通过数组名称定位到数组内存所在地址，所以不需要返回值即可实现数组的改变。 在sort(int arr[], int start, int end)中首先定义三个变量start、end、key用于标识数组下标游走的起始位置、数组下标游走的最终位置、基准值。 比较start和end，start &gt;= end时表明基于基准值key左右两边已摆好（左边值比基准值key小，右边值比基准值大）。 start &lt; end则进入循环，因为选定的基准值key为原数组第一个值，所以先对原数组进行从右至左的遍历，当遇到比基准值key大或等时将标识end减少1再进行判断，直到从右至左遍历原数组中值小于基准值key时退出循环之后将此位置的值与数组之前的标识start的值arr[start]替换位置；然后再进行从左至右的遍历，当遇到比基准值key小或等时将标识start增加1再进行判断，直到从左至右遍历原数组中值大于基准值key时退出循环之后将此位置的值与数组之前的标识end的值arr[end]替换位置。 最后通过递归将当前基准值两边的杂乱数据排序，直到标识start、end回归最初的初始标记也就是查询数组的下标起点low和下标终点high。 package com.group.demo2019524; public class QuitSort { int sort(int []arr, int start, int end) { int key=arr[start]; while(start&lt;end) { //先从右到左找小于key while(start&lt;end &amp;&amp; arr[end]&gt;key) { end--; } arr[start]=arr[end]; //再从左到右找大于key while(start&lt;end &amp;&amp; arr[start]&lt;key) { start++; } arr[end]=arr[start]; } arr[start]=key; return start; } void getIndex(int[] arr, int start, int end) { if(start&lt;end) { int index=sort(arr, start, end); //递归重复排左边的 getIndex(arr, start, index-1); //递归重复排右边的 getIndex(arr, index+1, end); } } public static void main(String[] args) { int arr[] = {12,20,5,16,15,1,30,45,23,9}; int start = 0; int end = arr.length - 1; new QuitSort().getIndex(arr, start, end); for(int a : arr){ System.out.print(a + &quot; &quot;); } } } 排序前：12 20 5 16 15 1 30 45 23 9排序后：1 5 9 12 15 16 20 23 30 45 直接插入排序基本思想： 把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。 实例：0.初始状态 3，1，5，7，2，4，9，6（共8个数）有序表：3；无序表：1，5，7，2，4，9，61.第一次循环，从无序表中取出第一个数 1，把它插入到有序表中，使新的数列依旧有序有序表：1，3；无序表：5，7，2，4，9，62.第二次循环，从无序表中取出第一个数 5，把它插入到有序表中，使新的数列依旧有序有序表：1，3，5；无序表：7，2，4，9，63.第三次循环，从无序表中取出第一个数 7，把它插入到有序表中，使新的数列依旧有序有序表：1，3，5，7；无序表：2，4，9，64.第四次循环，从无序表中取出第一个数 2，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，5，7；无序表：4，9，65.第五次循环，从无序表中取出第一个数 4，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，7；无序表：9，66.第六次循环，从无序表中取出第一个数 9，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，7，9；无序表：67.第七次循环，从无序表中取出第一个数 6，把它插入到有序表中，使新的数列依旧有序有序表：1，2，3，4，5，6，7，9；无序表：（空） package com.group.demo2019524; public class InsertSort { public static void main(String[] args) { int a[] = {3,1,5,7,2,4,9,6}; System.out.println(&quot;排序前：&quot;); for(int array :a) { System.out.print(array+&quot; &quot;); } new InsertSort().sort(a); System.out.println(&quot;\n排序后：&quot;); for(int array :a) { System.out.print(array+&quot; &quot;); } } private void sort(int[] a) { // TODO Auto-generated method stub int length=a.length; int j; for(int i=1;i &lt; length ; i++) { int temp = a[i]; for(j =i-1; j&gt;=0 &amp;&amp; a[j]&gt;temp ;j--) { a[j+1]=a[j]; } a[j+1]=temp; } } } 归并排序采用递归法： ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；③. 重复步骤②，直到所有元素排序完毕 package com.group.demo2019524; public class MergeSort { public static void merge(int[] a, int start, int mid, int end) { int[] tmp = new int[a.length]; System.out.println(&quot;merge &quot; + start + &quot;~&quot; + end); int i = start, j = mid + 1, k = start; while (i &lt; mid + 1 &amp;&amp; j &lt; end + 1) { if (a[i] &lt; a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } while (i != mid + 1) tmp[k++] = a[i++]; while (j != end + 1) tmp[k++] = a[j++]; for (i = start; i &lt;= end; i++) a[i] = tmp[i]; for (int p : a) System.out.print(p + &quot; &quot;); System.out.println(); } static void mergeSort(int[] a, int start, int end) { if (start &lt; end) { int mid = (start + end) / 2; mergeSort(a, start, mid);// 左边有序 mergeSort(a, mid + 1, end);// 右边有序 merge(a, start, mid, end); } } public static void main(String[] args) { int[] b = { 49, 38, 65, 97, 76, 13, 27, 50 }; mergeSort(b, 0, b.length - 1); } } 懒了http://ju.outofmemory.cn/entry/372908]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程]]></title>
    <url>%2F2019%2F01%2F19%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、概念线程：比进程更小的执行单位。多线程是多任务的一种特别的形式进程：是程序的一次动态执行过程,一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束2、生命周期线程生命周期： 新建状态：使用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序start()这个线程就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。运行状态：如果就绪状态的线程获取CPU资源，就可以执行run()，此时线程便处于运行状态。运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态阻塞状态：如果一个线程执行了sleep(睡眠)、suspend(挂起)等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可分为三种：等待阻塞：运行状态中的线程执行wait()方法，使线程进入到等待阻塞状态同步阻塞：线程在获取Synchronized同步锁失败（因为同步锁被其他线程占用）其他阻塞：通过调用线程的sleep()或join()发出了I/O请求时，线程就会进入到阻塞状态。当sleep()状态超时，join()等待线程终止或超时，或者I/O处理完毕，线程重新转入就绪状态。死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。3、线程的优先级每一个java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java线程的优先级是一个整数，取值范围是1-10默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY(5).具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。创建一个线程4、Java 提供了三种创建线程的方法：通过实现 Runnable 接口；通过继承 Thread 类本身；通过 Callable 和 Future 创建线程。 //继承Thread类 package com.group.demo2019525; public class MyThread extends Thread{ private String name; public MyThread(String name) { this.name=name; } @Override public void run() { // TODO Auto-generated method stub for(int i = 10 ; i &gt;0 ; i --) { System.out.println(name+&quot;执行&quot;+i); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } //实现Runnable接口 package com.group.demo2019525; public class MyThread2 implements Runnable{ private String name; public MyThread2(String name) { this.name = name; } @Override public void run() { // TODO Auto-generated method stub for(int i =0; i &lt; 10; i++) { System.out.println(name+&quot;执行了&quot;+i); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } package com.group.demo2019525; public class MyTest { public static void main(String[] args) { MyThread mythread1 = new MyThread(&quot;A&quot;); mythread1.start(); new Thread(new MyThread2(&quot;B&quot;)).start();; } } 5、Thread和Runnable的差别实现Runable接口比继承Thread类所具有的优势：1、适合多个同样的程序代码的线程去处理同一个资源2、能够避免java中的单继承的限制3、添加程序的健壮性，代码能够被多个线程共享，代码和数据独立4、线程池仅仅能放入实现Runable或callable类线程，不能直接放入继承Thread的类 6、多线程不安全例子 //吃苹果案例 package com.group.demo2019525; public class ThreadProblem implements Runnable { private int num = 10; @Override public void run() { for (int i = 0; i &lt; 10; i++) { if(num &gt; 0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;吃了编号为&quot;+num+&quot;的苹果&quot;); num--; } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } package com.group.demo2019525; public class MyTest { public static void main(String[] args) { ThreadProblem tp = new ThreadProblem(); new Thread(tp,&quot;A&quot;).start(); new Thread(tp,&quot;B&quot;).start(); } } B吃了编号为20的苹果A吃了编号为20的苹果A吃了编号为18的苹果B吃了编号为18的苹果B吃了编号为16的苹果A吃了编号为16的苹果B吃了编号为14的苹果A吃了编号为14的苹果A吃了编号为12的苹果B吃了编号为12的苹果B吃了编号为10的苹果A吃了编号为10的苹果A吃了编号为8的苹果B吃了编号为8的苹果B吃了编号为6的苹果A吃了编号为6的苹果B吃了编号为4的苹果A吃了编号为4的苹果A吃了编号为2的苹果B吃了编号为1的苹果A吃了编号为0的苹果 线程安全问题产生的原因：1、多个线程在操作共享的数据。2、操作共享数据的线程代码有多条。3、当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。 7、解决思路:就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。在java中，用同步代码块就可以解决这个问题。同步代码块的格式 package com.group.demo2019525; public class ThreadProblem implements Runnable { private int num = 20; @Override public void run() { for (int i = 0; i &lt; 20; i++) { synchronized (ThreadProblem.class) { if(num &gt; 0){ try { Thread.sleep(10); System.out.println(Thread.currentThread().getName()+&quot;吃了编号为&quot;+num+&quot;的苹果&quot;); --num; } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } }]]></content>
      <categories>
        <category>java se</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2019%2F01%2F12%2F%E7%94%A8hexo%E6%90%AD%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[配置本地环境1、下载安装这两个软件 Git-2.21.0-64-bit.exe node-v10.15.3-x64.msi 如下图 2、在自己电脑某个盘里新建一个文件夹(自定义名称) 我的文件夹名称为 czjblog 3、然后在文件夹里，右键—&gt;选择Git Bash Here 就打开另一个窗口了，如下图 4、安装hexo 用命令 npm install hexo –g 如果网络好的话很快就行了 5、检查一下是否安装成功 用命令 hexo –v 出现以下图说明成功了 6、初始化自己创建的文件夹 用命令 hexo init 7、生成静态页面 用命令 hexo g 8、启动项目 用命令 hexo s 出现如下图说明启动成功 去浏览器输入 http://localhost:4000 来访问了. 配置github环境1、 首先得去github官网上面去注册一个账号 2、 然后新建一个仓库依赖，如下图 3、 然后来到这页面，如下图 https://github.com/caozhongjue/caozhongjue.github.io.git git@github.com:caozhongjue/caozhongjue.github.io.git 4、然后修改本地博客目录的配置： 修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： type: git repository: git@github.com:caozhongjue/caozhongjue.github.io.git //caozhongjue换为自己的 branch: master 5、控制台命令：npm install –save hexo-deployer-git //安装部署插件 6、由于我是用ssh 与github关联的，所以得操作这步，输入命令 ssh-keygen -t rsa -C “2857113935@qq.com” 连续回车三下生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）如下图 7、经过上面的步骤，在C:\Users\Administrator.ssh下面生成了一个id_rsa.pub文件，把里面的内容复制到 github ssh安全那里，如下面 标题随便填，键是id_rsa.pub文件里面的内容。 8、可以使用hexo d 发布项目到github上面去了 如下图 更改默认主题样式Next主题的使用说明 http://theme-next.iissnan.com/getting-started.html 1、 使用命令 git clone https://github.com/iissnan/hexo-theme-next 2、 修改项目目录下_config.yml文件内容，把theme：后面的内容换为next theme: hexo-theme-next #修改网站主题样式 title: czj’blog # author: czj #修改作者 language: zh-Hans #修改网站的显示语言，这里是中文 3、 修改项目目录下hexo-theme-next 主题下的_config.yml文件内容， menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive上面这几个就是下面的 1、添加分类模块 命令如下 hexo new page categories 你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为 title: 分类 3、打开 主题配置文件 找到menu，将categorcies取消注释 4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子： title: 分类测试文章标题 categories: 分类名 添加标签模块 命令hexo new page tags 同上 添加关于模块 命令hexo new page about 同上 highlight_theme: night bright #代码的样式 avatar: https://s2.ax1x.com/2019/05/23/VPZiAe.png #设置头像 4、 添加搜索功能 4.1、安装 hexo-generator-searchdb 插件 npm install hexo-generator-searchdb –save 4.2、打开 站点配置文件 找到Extensions在下面添加 search: path: search.xml field: post format: html limit: 100004.3、打开 主题配置文件 找到Local search，将enable设置为true 5、修改文章内链接文本样式 打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 6、首页的文章只显示一半用文本编辑器打开 themes/next 目录下的 _config.yml 文件，找到这段代码： auto_excerpt: enable: false length: 150把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。 修改后重启 hexo 就ok了。 项目的目录结构 source 文件夹存放着用markdown编辑器写的章 每次添加文章都是用markdown编辑器写好保存，放到source下面的_post文件夹下面去themes 这里存放着样式_config.yml 主站点配置文件 ，themes样式文件夹下面的文件夹里也有个样式配置文件可以使用MarkdownPad2编辑器写文章，写完后，把那个.md文章放到source下的_post文件夹下，然后右键打开窗口， 依次使用命令 hexo clean , hexo g ,hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F01%2F12%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[####]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
